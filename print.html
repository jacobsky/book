<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The godot-rust Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello, world!</a></li></ol></li><li class="chapter-item expanded "><a href="gdnative-overview.html"><strong aria-hidden="true">3.</strong> An Overview of GDNative</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gdnative-overview/data-representations.html"><strong aria-hidden="true">3.1.</strong> Data representations</a></li><li class="chapter-item expanded "><a href="gdnative-overview/wrappers.html"><strong aria-hidden="true">3.2.</strong> Ref, TRef and Instance</a></li><li class="chapter-item expanded "><a href="gdnative-overview/architecture.html"><strong aria-hidden="true">3.3.</strong> Game architecture</a></li></ol></li><li class="chapter-item expanded "><a href="rust-binding.html"><strong aria-hidden="true">4.</strong> Binding to Rust code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-binding/classes.html"><strong aria-hidden="true">4.1.</strong> Class registration</a></li><li class="chapter-item expanded "><a href="rust-binding/methods.html"><strong aria-hidden="true">4.2.</strong> Exported methods</a></li><li class="chapter-item expanded "><a href="rust-binding/properties.html"><strong aria-hidden="true">4.3.</strong> Exported properties</a></li><li class="chapter-item expanded "><a href="rust-binding/to-variant-from-variant-export.html"><strong aria-hidden="true">4.4.</strong> ToVariant, FromVariant and Export</a></li><li class="chapter-item expanded "><a href="rust-binding/calling-gdscript.html"><strong aria-hidden="true">4.5.</strong> Calling into GDScript from Rust</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="faq/code.html"><strong aria-hidden="true">5.1.</strong> Common code questions</a></li><li class="chapter-item expanded "><a href="faq/multithreading.html"><strong aria-hidden="true">5.2.</strong> Multithreading</a></li><li class="chapter-item expanded "><a href="faq/configuration.html"><strong aria-hidden="true">5.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="faq/support.html"><strong aria-hidden="true">5.4.</strong> Versioning and supported platforms</a></li><li class="chapter-item expanded "><a href="faq/community.html"><strong aria-hidden="true">5.5.</strong> Community</a></li><li class="chapter-item expanded "><a href="faq/godot4.html"><strong aria-hidden="true">5.6.</strong> Godot 4.0 Status</a></li></ol></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.</strong> (TODO) Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/structure.html"><strong aria-hidden="true">6.1.</strong> Structuring code for testing</a></li><li class="chapter-item expanded "><a href="testing/engine.html"><strong aria-hidden="true">6.2.</strong> Testing with the engine</a></li></ol></li><li class="chapter-item expanded "><a href="recipes.html"><strong aria-hidden="true">7.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recipes/async-tokio.html"><strong aria-hidden="true">7.1.</strong> Async with Tokio runtime</a></li><li class="chapter-item expanded "><a href="recipes/custom-node-plugin.html"><strong aria-hidden="true">7.2.</strong> Custom node plugin</a></li><li class="chapter-item expanded "><a href="recipes/external-resources.html"><strong aria-hidden="true">7.3.</strong> Loading external resources</a></li><li class="chapter-item expanded "><a href="recipes/logging.html"><strong aria-hidden="true">7.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="recipes/nix-build-system.html"><strong aria-hidden="true">7.5.</strong> Nix as development environment</a></li><li class="chapter-item expanded "><a href="recipes/panic-handler.html"><strong aria-hidden="true">7.6.</strong> Rust panic handler</a></li></ol></li><li class="chapter-item expanded "><a href="projects.html"><strong aria-hidden="true">8.</strong> Third-party projects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="projects/games.html"><strong aria-hidden="true">8.1.</strong> Games</a></li><li class="chapter-item expanded "><a href="projects/tools.html"><strong aria-hidden="true">8.2.</strong> Tools and integrations</a></li><li class="chapter-item expanded "><a href="projects/applications.html"><strong aria-hidden="true">8.3.</strong> Applications</a></li></ol></li><li class="chapter-item expanded "><a href="exporting.html"><strong aria-hidden="true">9.</strong> Exporting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exporting/android.html"><strong aria-hidden="true">9.1.</strong> Android</a></li><li class="chapter-item expanded "><a href="exporting/ios.html"><strong aria-hidden="true">9.2.</strong> (TODO) iOS</a></li><li class="chapter-item expanded "><a href="exporting/macosx.html"><strong aria-hidden="true">9.3.</strong> Mac OS X</a></li></ol></li><li class="chapter-item expanded "><a href="advanced-guides.html"><strong aria-hidden="true">10.</strong> Advanced Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced-guides/custom-godot.html"><strong aria-hidden="true">10.1.</strong> Using custom Godot versions</a></li><li class="chapter-item expanded "><a href="advanced-guides/migrating-0-8.html"><strong aria-hidden="true">10.2.</strong> Migrating from godot-rust 0.8</a></li><li class="chapter-item expanded "><a href="advanced-guides/migrating-0-9.html"><strong aria-hidden="true">10.3.</strong> Migrating from godot-rust 0.9</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The godot-rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the <code>godot-rust</code> book! This is a work-in-progress user guide for the Rust bindings to GDNative.</p>
<p>If you're new to <code>godot-rust</code>, try the <a href="./getting-started.html">Getting Started</a> tutorial first!</p>
<p>For more information about architecture with <code>godot-rust</code>, the <a href="gdnative-overview.html">GDNative Overview</a> gives a broad overview for <em>how</em> <code>godot-rust</code> can be used with a few different use-cases as well as some indepth information for the underlying API.</p>
<p>If have specific code questions that are not covered in the Getting Started guide, please check out the <a href="faq.html">Frequently Asked Questions</a> or <a href="recipes.html">Recipes</a> for some additional resources related to configuring <code>godot-rust</code>.</p>
<p>If you're new to Rust, before getting started, it is highly recommended that you familiarize yourself with all of the concepts outlined in the officially maintained <a href="https://doc.rust-lang.org/book/">Rust Book</a> before you getting started with <code>godot-rust</code>.</p>
<p>If you have used earlier versions of <code>godot-rust</code> before, see <a href="advanced-guides/migrating-0-8.html">Migrating from godot-rust 0.8</a> for a quick guided tour to the new API.</p>
<h2 id="about-godot-rust"><a class="header" href="#about-godot-rust">About godot-rust</a></h2>
<p>This project specifically supports the <a href="https://www.rust-lang.org/">Rust Programming Language</a> bindings to the <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/gdnative/gdnative-cpp-example.html">GDNative API</a> for the Godot Game Engine.</p>
<p>Outside of personal preference, Rust may be a good choice for your game for some of the following reasons:</p>
<ul>
<li>Native levels of performance.</li>
<li>Memory safety validated at compile time.*</li>
<li><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless Concurrency</a>.*</li>
<li>The leveraging the <a href="https://doc.rust-lang.org/stable/cargo/">cargo</a> build system to build the GDNative library. </li>
<li>The ability to leverage Rust's crate ecosystem from <a href="https://crates.io/">crates.io</a>. </li>
</ul>
<p>*: Compile time memory and thread safety guarantees only apply to the Rust code. As the user is allowed to call into the Godot engine (C++ code, via GDNative Foreign Function Interface) or into user-defined scripts (GDScript), some of the validity checks are outside godot-rust's control. However, <code>godot-rust</code> guides the user by making clear which operations are potentially unsafe.</p>
<p>For more information about the <code>godot-rust</code> project and how it may be useful to you, please refer to the <a href="faq/meta.html">FAQ Section</a> for project specific information.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>The source repository for this book is <a href="https://github.com/godot-rust/book">hosted on GitHub</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The <code>godot-rust</code> bindings, and this user guide, are licensed under the <a href="LICENSE.html">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>The getting started tutorial will introduce you to basic godot-rust concepts. At the end of the tutorial, you'll have a working copy of the <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/dodge-the-creeps">dodge-the-creeps example</a> from the main repo.</p>
<p>This tutorial assumes some experience with Godot's GUI and GDScript. It assumes a basic understanding of Rust itself.</p>
<h2 id="work-in-progress"><a class="header" href="#work-in-progress">Work-in-progress</a></h2>
<p><strong>The Getting Started tutorial is a work-in-progress, and currently it only covers up to the hello-world example!</strong> To learn more about the API after the tutorial, you'll have to dive into the <a href="https://docs.rs/gdnative/latest">documentation on docs.rs</a>, and the <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/">other examples in the main repo</a>. If you have any questions using the bindings, ask away in the <code>#gdnative_dev</code> channel on the <a href="https://godotengine.org/community">Godot Engine community Discord server</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>Before we can start creating a hello-world project using godot-rust, we'll need to install the necessary software.</p>
<h2 id="godot-engine"><a class="header" href="#godot-engine">Godot Engine</a></h2>
<p>The default API version is currently 3.2.3-stable. For the rest of the tutorial, we'll assume that you have Godot 3.2.3-stable installed, and available in your <code>PATH</code> as <code>godot</code>.</p>
<p>You may download binaries of Godot 3.2.3-stable from the official repository: <a href="https://downloads.tuxfamily.org/godotengine/3.2.3/">https://downloads.tuxfamily.org/godotengine/3.2.3/</a>.</p>
<blockquote>
<h3 id="using-another-build-of-the-engine"><a class="header" href="#using-another-build-of-the-engine">Using another build of the engine</a></h3>
<p>For simplicity, we assume that you use the official build of 3.2.3-stable for the Getting Started tutorial. If you want to use another version of the engine, see the <a href="getting-started/../advanced-guides/custom-godot.html">Using custom builds of Godot</a> guide.</p>
</blockquote>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p><a href="https://rustup.rs/">rustup</a> is the recommended way to install the Rust toolchain, including the compiler, standard library, and Cargo, the package manager. Visit <a href="https://rustup.rs/">https://rustup.rs/</a> to see instructions for your platform.</p>
<p>After installation of rustup and the <code>stable</code> toolchain, check that they were installed properly:</p>
<pre><code class="language-bash"># Check Rust toolchain installer version
rustup -V
# Check Rust version
rustc --version
# Check Cargo version
cargo -V
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>When working on Windows, it's also necessary to install the <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio Build Tools</a>, or the full Visual Studio (<em>not</em> Visual Studio Code). More details can be found on <a href="https://github.com/rust-lang/rustup#working-with-rust-on-windows">Working with Rust on Windows</a>.</p>
<h2 id="llvm"><a class="header" href="#llvm">LLVM</a></h2>
<p>The godot-rust bindings depend on <code>bindgen</code>, which in turn <a href="https://rust-lang.github.io/rust-bindgen/requirements.html">depends on LLVM</a>. You may download LLVM binaries from <a href="https://releases.llvm.org/">https://releases.llvm.org/</a>.</p>
<p>After installation, check that LLVM was installed properly:</p>
<pre><code class="language-bash"># Check if Clang is installed and registered in PATH
clang -v
</code></pre>
<p><code>bindgen</code> may complain about a missing <code>llvm-config</code> binary, but it is not actually required to build the <code>gdnative</code> crate. If you see a warning about <code>llvm-config</code> and a failed build, it's likely that you're having a different problem!</p>
<h2 id="using-the-template"><a class="header" href="#using-the-template">Using the template</a></h2>
<p>One way to get started with godot-rust is a full-fledged (inofficial) template, which can be found <a href="https://github.com/macalimlim/godot-rust-template">here</a> to get you started right away. All the boilerplate stuff is already done for you, however, using the template requires you to set up extra dependencies and toolchains. Check out the <a href="https://github.com/macalimlim/godot-rust-template/wiki">wiki</a> for instructions on how to get started with the template.</p>
<p>The template is not maintained by us, and might not work in all setups where the base library would be compatible. If you encounter any issues with the template, please report them at its <a href="https://github.com/macalimlim/godot-rust-template/issues/">issue tracker</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h1>
<p>Follow this tutorial to learn how to create an empty project that simply prints &quot;Hello, world!&quot; to the Godot console on ready. The code might not compile or work as intended while it's in-progress, but at the end of this section, the code will be compiling and working fine.</p>
<p>The full, finished code is available in the main repo: <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/hello-world">https://github.com/godot-rust/godot-rust/tree/master/examples/hello-world</a>.</p>
<h2 id="creating-the-project"><a class="header" href="#creating-the-project">Creating the project</a></h2>
<p>First, create an empty project using the Godot GUI. Then, create an empty crate <em>beside</em> the project folder using <code>cargo</code>:</p>
<pre><code class="language-sh">cargo init --lib my-gdnative-lib
</code></pre>
<p>Your file structure should look like this:</p>
<pre><code>.
├─── my-gdnative-lib
│   ├─── src
│   │   ├   lib.rs
│   ├   Cargo.toml
├─── my-godot-project
│   ├─── .import
│   ├   icon.png
│   ├   icon.png.import
│   └   project.godot
</code></pre>
<p>Once the project is created, open <code>Cargo.toml</code>, change the crate type to <code>cdylib</code>, and add <code>gdnative</code> as a dependency:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
gdnative = &quot;0.10&quot;
</code></pre>
<blockquote>
<h3 id="organization-of-rust-code"><a class="header" href="#organization-of-rust-code">Organization of Rust code</a></h3>
<p>While it's also possible to place the Rust crate within the Godot project, doing so might lead to problems with Godot's resource importer. It's best to place the Rust crate somewhere outside the Godot project directory.</p>
<p>Previously, some third-party resources have recommended separating Rust code into multiple crates. While this is fine to do, godot-rust works best when there is a single <code>cdylib</code> crate acting as the entry point for all crates in the workspace. Script downcasting, for example, only works for types registered in the same GDNative library. Code from <code>std</code> and other dependencies can also lead to code bloat when duplicated in multiple binaries.</p>
<p>We suggest that users start projects as a single crate, and only split code into workspaces when necessary.</p>
</blockquote>
<h2 id="boilerplate"><a class="header" href="#boilerplate">Boilerplate</a></h2>
<p>You should now be able to compile your crate into a dynamic library, but a little bit of boilerplate is required before Godot can actually be able to load it as a GDNative library. Replace the contents of <code>lib.rs</code> with the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;

// Function that registers all exposed classes to Godot
fn init(handle: InitHandle) {
}

// Macro that creates the entry-points of the dynamic library.
godot_init!(init);
<span class="boring">}
</span></code></pre></pre>
<p>The code does several things:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>This imports a number of commonly used types and traits into the scope. Generally, you'll want this at the top of every file where you need to interact with GDNative.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function that registers all exposed classes to Godot
fn init(handle: InitHandle) {
}
<span class="boring">}
</span></code></pre></pre>
<p>This declares an empty callback function, which is called when the library is loaded by Godot. All script classes in the library should be &quot;registered&quot; here using <code>handle.add_class::&lt;MyNativeClass&gt;()</code>. You only need <em>one</em> of this in the entire library.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Macro that creates the entry-points of the dynamic library.
godot_init!(init);
<span class="boring">}
</span></code></pre></pre>
<p>This macro defines the necessary C callbacks used by Godot. You only need <em>one</em> invocation of this macro in the entire library. Note how the <code>init</code> function defined earlier is given to the <code>godot_init!</code> macro as a callback.</p>
<blockquote>
<h3 id="gdnative-internals"><a class="header" href="#gdnative-internals">GDNative internals</a></h3>
<p>The purposes of this macro will be discussed in detail in <a href="getting-started/../gdnative-overview.html"><em>An Overview of GDNative</em></a>. For now, treat it as a magic incantation.</p>
</blockquote>
<h2 id="your-first-script"><a class="header" href="#your-first-script">Your first script</a></h2>
<p>With the boilerplate put into place, you can now create your first Rust script! We will go step by step and discover what's needed to create script &quot;classes&quot;. Intermediate code versions might not compile, but at the end of this section it should be working!</p>
<p>A script is simply a Rust type that implements (derives) the <code>NativeClass</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The HelloWorld &quot;class&quot;
#[derive(NativeClass)]
#[inherit(Node)]
pub struct HelloWorld;

// Function that registers all exposed classes to Godot
fn init(handle: InitHandle) {
    // Register the new `HelloWorld` type we just declared.
    handle.add_class::&lt;HelloWorld&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>Similar to the GDScript <code>extends</code> directive, the <code>inherit</code> attribute tells godot-rust the most general base class your script can be attached to. Here, <code>Node</code> is the parent class of all nodes in the scene tree, so it would be possible to attach <code>HelloWorld</code> to any node or scene in Godot.</p>
<p>Unfortunately, this won't compile just yet: Rust will complain about the lack of a <code>new</code> method and a <code>NativeClassMethods</code> trait. This is because all scripts must also have a zero-argument constructor and a set of exported methods. To fix this, simply add two <code>impl</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You may add any number of ordinary `impl` blocks as you want. However, ...
impl HelloWorld {
    /// The &quot;constructor&quot; of the class.
    fn new(_owner: &amp;Node) -&gt; Self {
        HelloWorld
    }
}

// Only __one__ `impl` block can have the `#[methods]` attribute, which
// will generate code to automatically bind any exported methods to Godot.
#[methods]
impl HelloWorld {
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>HelloWorld</code> type is like any regular Rust type, and can have any number of ordinary <code>impl</code> blocks. However, it must have <strong>one and only one</strong> <code>impl</code> block with the <code>#[methods]</code> attribute, which tells godot-rust to generate code that automatically binds any exported methods to Godot.</p>
<h2 id="creating-the-nativescript-resource"><a class="header" href="#creating-the-nativescript-resource">Creating the NativeScript resource</a></h2>
<p>You should now be able to build the dynamic library with a <code>HelloWorld</code> script class in it. However, we also need to tell Godot about it. To do this, build the library with <code>cargo build</code>.</p>
<p>After building the library with <code>cargo build</code>, the resulting library should be in the <code>target/debug/</code> folder. Copy it (or create a symbolic link to it) somewhere inside the Godot project directory.</p>
<p>To tell Godot about the <code>HelloWorld</code> class, a <code>GDNativeLibrary</code> resource has to be created. This can be done in the &quot;Inspector&quot; panel in the Godot editor by clicking the &quot;new resource&quot; button in the top left.</p>
<p>With the <code>GDNativeLibrary</code> resource created, the path to the generated binary can be set in the editor. After specifying the path, save the <code>GDNativeLibrary</code> resource into a resource file by clicking the &quot;tool&quot; button in the Inspector panel in the top right.</p>
<p>Now, the <code>HelloWorld</code> class can be added to any node by clicking the &quot;add script&quot; button. In the popup, select &quot;NativeScript&quot; as the language, and set the class name to <code>HelloWorld</code>. Then, select the <code>NativeScript</code> resource in the Inspector, click the <code>library</code> field and point to the <code>GDNativeLibrary</code> resource that you created earlier.</p>
<h2 id="overriding-a-godot-method"><a class="header" href="#overriding-a-godot-method">Overriding a Godot method</a></h2>
<p>You can now run your project from the editor! If all goes correctly, it should launch but do nothing. That's because we haven't added any actual behaviors yet! To make our script actually do something, we can override the <a href="https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-ready"><code>_ready</code></a> method in the <code>impl</code> block with the <code>#[methods]</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only __one__ `impl` block can have the `#[methods]` attribute, which
// will generate code to automatically bind any exported methods to Godot.
#[methods]
impl HelloWorld {

    // To make a method known to Godot, use the #[export] attribute.
    // In Godot, script &quot;classes&quot; do not actually inherit the parent class.
    // Instead, they are &quot;attached&quot; to the parent object, called the &quot;owner&quot;.
    //
    // In order to enable access to the owner, it is passed as the second
    // argument to every single exposed method. As a result, all exposed
    // methods MUST have `owner: &amp;BaseClass` as their second arguments,
    // before all other arguments in the signature.
    #[export]
    fn _ready(&amp;self, _owner: &amp;Node) {
        // The `godot_print!` macro works like `println!` but prints to the Godot-editor
        // output tab as well.
        godot_print!(&quot;Hello, world!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the <code>#[export]</code> attribute is used to tell godot-rust to expose your methods to Godot. In this case, we are overriding <a href="https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-ready"><code>_ready</code></a> and printing a line of text.</p>
<p>Now, re-compile the crate using <code>cargo build</code> and copy the resulting binary to the Godot project. Launch the project from the editor, and you should see <code>Hello, world!</code> in the Godot console!</p>
<h2 id="wrapping-it-up"><a class="header" href="#wrapping-it-up">Wrapping it up</a></h2>
<p>Congratulations! You have just created your first Rust GDNative library. You have learned how to expose scripts and methods to Godot using the bindings, and how to use them in Godot. A lot of the details are still unexplained, but you're off to a good start!</p>
<p>You can find the full code for this example in the main repo: <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/hello-world">https://github.com/godot-rust/godot-rust/tree/master/examples/hello-world</a>.</p>
<h2 id="work-in-progress-1"><a class="header" href="#work-in-progress-1">Work-in-progress</a></h2>
<p><strong>The Getting Started tutorial is a work-in-progress, and unfortunately it ends here for now!</strong> To learn more about the API, you'll have to dive into the <a href="https://docs.rs/gdnative/latest">documentation on docs.rs</a>, and the <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/">other examples in the main repo</a>. If you have any questions using the bindings, ask away in the <code>#gdnative_dev</code> channel on the <a href="https://godotengine.org/community">Godot Engine community Discord server</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-overview-of-gdnative"><a class="header" href="#an-overview-of-gdnative">An Overview of GDNative</a></h1>
<p>GDNative is the interface between the Godot engine and bindings in native languages, such as C, C++ or Rust.</p>
<p>This chapter gives a broad overview of basic GDNative concepts and godot-rust's approach to implement them in Rust. It is not a usage guide for exposing your Rust code to Godot; see chapter <a href="rust-binding.html">Binding to Rust code</a> for concrete examples.</p>
<p>Subchapters:</p>
<ol>
<li><a href="gdnative-overview/data-representations.html">Data representations</a></li>
<li><a href="gdnative-overview/wrappers.html"><code>Ref</code>, <code>TRef</code> and <code>Instance</code></a></li>
<li><a href="gdnative-overview/architecture.html">Game architecture</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-representations"><a class="header" href="#data-representations">Data representations</a></h1>
<p>The godot-rust library uses many different approaches to store and transport data. This chapter explains high-level concepts of related terminology used throughout the library and its documentation. It is not a usage guide however -- to see the concepts in action, check out <a href="gdnative-overview/../rust-binding.html">Binding to Rust code</a>.</p>
<h2 id="object-and-class"><a class="header" href="#object-and-class">Object and class</a></h2>
<p>Godot is built around <em>classes</em>, object-oriented types in a hierarchy, with the base class <code>Object</code> at the top. When talking about classes, we explicitly mean classes in the <code>Object</code> hierarchy and not built-in types like <code>String</code>, <code>Vector2</code>, <code>Color</code>, even though they are technically classes in C++. In Rust, classes are represented as structs.</p>
<p>Every user-defined class inherits <code>Object</code> directly or indirectly, and thus all methods defined in <code>Object</code> are accessible on <em>any</em> instance of a user-defined class. This type includes functionality for:</p>
<ul>
<li>object lifetime: <code>_init</code> (<code>new</code> in Rust), <code>free</code></li>
<li>identification and printing: <code>to_string</code>, <code>get_instance_id</code></li>
<li>reflection/introspection: <code>get_class</code>, <code>get</code>, <code>has_method</code>, ...</li>
<li>custom function invocation: <code>call</code>, <code>callv</code>, <code>call_deferred</code></li>
<li>signal handling: <code>connect</code>, <code>emit_signal</code>, ...</li>
</ul>
<p><code>Object</code> itself comes with manual memory management. All instances must be deallocated using the <code>free()</code> method. This is typically not what you want, instead you will most often work with the following classes inherited from <code>Object</code>:</p>
<ul>
<li><strong><code>Reference</code></strong><br />
Reference-counted objects. This is the default base class if you don't use the <code>extends</code> keyword in GDScript. Allows to pass around instances of this type freely, managing memory automatically when the last reference goes out of scope.<br />
Do not confuse this type with the godot-rust <code>Ref</code> smart pointer.</li>
<li><strong><code>Node</code></strong><br />
Anything that's part of the scene tree, such as <code>Spatial</code> (3D), <code>CanvasItem</code> and <code>Node2D</code> (2D). Each node in the tree is responsible of its children and will deallocate them automatically when it is removed from the tree. At the latest, the entire tree will be destroyed when ending the application.<br />
<strong>Important:</strong> as long as a node is not attached to the scene tree, it behaves like an <code>Object</code> instance and must be freed manually. On the other hand, as long as it is part of the tree, it can be destroyed (e.g. when its parent is removed) and other references pointing to it become invalid.</li>
<li><strong><code>Resource</code></strong><br />
Data set that is loaded from disk and cached in memory, for example 3D meshes, materials, textures, fonts or music (see also <a href="https://docs.godotengine.org/en/stable/getting_started/step_by_step/resources.html">Godot tutorial</a>).
<code>Resource</code> inherits <code>Reference</code>, so in the context of godot-rust, it can be treated like a normal, reference-counted class. </li>
</ul>
<p>When talking about inheritance, we always mean the relationship in GDScript code. Rust does not have inheritance, instead godot-rust implements <code>Deref</code> traits to allow implicit upcasts. This enables to invoke all parent methods and makes the godot-rust API very close to GDScript.</p>
<p>Classes need to be added as <code>NativeScript</code> resources inside the Godot editor, see <a href="gdnative-overview/../getting-started/hello-world.html#creating-the-nativescript-resource">here</a> for a description.</p>
<p><em>See <code>Object</code> in
<a href="https://docs.rs/gdnative/latest/gdnative/api/struct.Object.html">godot-rust docs</a>,
<a href="https://docs.godotengine.org/en/latest/classes/class_object.html">Godot docs</a></em><br />
<em>See <code>GodotObject</code>, the Rust trait implemented for all Godot classes, in <a href="https://docs.rs/gdnative/latest/gdnative/trait.GodotObject.html">godot-rust docs</a></em></p>
<h2 id="variant"><a class="header" href="#variant">Variant</a></h2>
<p><code>Variant</code> is a type that can hold an instance of <em>any</em> type in Godot. This includes all classes (of type <code>Object</code>) as well as all built-in types such as <code>int</code>, <code>String</code>, <code>Vector2</code> etc.</p>
<p>Since GDScript is a dynamic language, you often deal with variants implicitly. Variables which are not type-annotated can have values of multiple types throughout their lifetime. In static languages like Rust, every value must have a defined type, thus untyped values in GDScript correspond to <code>Variant</code> in Rust. Godot APIs which accept any type as parameter are declared as <code>Variant</code> in the GDNative bindings (and thus godot-rust library). Sometimes, godot-rust also provides transparent mapping from/to concrete types behind the scenes.</p>
<p>Variants also have a second role as a serialization format between Godot and Rust. It is possible to extend this beyond the built-in Godot types. To make your own types convertible from and to variants, implement the traits <a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.FromVariant.html"><code>FromVariant</code></a> and <a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.ToVariant.html"><code>ToVariant</code></a>. Types that can only be safely converted to variants by giving up ownership can use <a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.OwnedToVariant.html">OwnedToVariant</a>, which is similar to the Rust <code>Into</code> trait.</p>
<p><em>See <code>Variant</code> in
<a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.Variant.html">godot-rust docs</a>,
<a href="https://docs.godotengine.org/en/latest/classes/class_variant.html">Godot docs</a></em></p>
<h2 id="script"><a class="header" href="#script">Script</a></h2>
<p>Scripts are programmable building blocks that can be attached to nodes in the scene tree, in order to customize their behavior. Depending on the language in which the script is written, there are different classes which inherit the <code>Script</code> class; relevant here will be <code>NativeScript</code> for classes defined in Rust, and <code>GDScript</code> for classes defined in GDScript. Scripts are stored as Godot resources (like materials, textures, shaders etc), usually in their own separate file.</p>
<p>Scripts <em>always</em> inherit another class from Godot's <code>Object</code> hierarchy, either an existing one from Godot or a user-defined one. In Rust, scripts are limited to inherit an existing Godot class; other scripts cannot be inherited. This makes each script a class on their own: they provide the properties and methods from their <em>base object</em>, plus all the properties and methods that you define in the script. </p>
<p><em>See <code>Script</code> in
<a href="https://docs.rs/gdnative/latest/gdnative/api/struct.Script.html">godot-rust docs</a>,
<a href="https://docs.godotengine.org/en/latest/classes/class_script.html">Godot docs</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ref-tref-and-instance"><a class="header" href="#ref-tref-and-instance"><code>Ref</code>, <code>TRef</code> and <code>Instance</code></a></h1>
<p>Objects from Godot, such as scene nodes, materials, or other resources are owned and maintained by the Godot engine. This means that your Rust code will store references to existing objects, not values. godot-rust provides special wrapper types to deal with these references, which are explained in this page.</p>
<p>These classes stand in contrast to value types like <code>bool</code>, <code>int</code>, <code>Vector2</code>, <code>Color</code> etc., which are copied in GDScript, not referenced. In Rust, those types either map to built-in Rust types or structs implementing the <code>Copy</code> trait.</p>
<h2 id="ref-persistent-reference"><a class="header" href="#ref-persistent-reference"><code>Ref</code>: persistent reference</a></h2>
<p>The generic smart pointer <code>gdnative::Ref&lt;T, Access&gt;</code> allows you to store <code>Object</code> instances in Rust. It comes with different access policies, depending on how the memory of the underlying object is managed (consult <a href="https://docs.rs/gdnative/latest/gdnative/struct.Ref.html">the docs</a> for details). Most of the time, you will be working with <code>Ref&lt;T&gt;</code>, which is the same as <code>Ref&lt;T, Shared&gt;</code> and the only access policy that is explained here. Its memory management mirrors that of the underlying type:</p>
<ul>
<li>for all Godot objects inheriting the <code>Reference</code> class, <code>Ref&lt;T&gt;</code> is reference-counted like <code>Arc&lt;T&gt;</code> and will clean up automatically.</li>
<li>for all other types (i.e. the type <code>Object</code> and inheritors of <code>Node</code>), <code>Ref&lt;T&gt;</code> behaves like a raw pointer with manual memory management.</li>
</ul>
<p>For example, storing a reference to a Godot <code>Node2D</code> instance in a struct would look as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GodotNode {
	node_ref: Ref&lt;Node2D&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><em>See <code>Ref</code> in
<a href="https://docs.rs/gdnative/latest/gdnative/struct.Ref.html">godot-rust docs</a></em></p>
<h2 id="tref-temporary-reference"><a class="header" href="#tref-temporary-reference"><code>TRef</code>: temporary reference</a></h2>
<p>While <code>Ref</code> is a persistent pointer to retain references to Godot objects for an extended period of time, it doesn't grant access to the underlying Godot object. The reason for this is that <code>Ref</code> cannot generally guarantee that the underlying object, which is managed by the Godot engine, is valid at the time of the access. However, you as a user are in control of GDScript code and the scene tree, thus you can assert that an object is valid at a certain point in time by using <code>assume_safe()</code>. This is an unsafe function that returns a <code>gdnative::TRef&lt;T, Access&gt;</code> object, which allows you to call methods on the node. You are responsible for this assumption to be correct; violating it can lead to undefined behavior.</p>
<p>The following example demonstrates <code>TRef</code>. A node is stored inside a Rust struct, and its position is modified through <code>set_position()</code>. This approach could be used in an ECS (Entity-Component-System) architecture, where <code>GodotNode</code> is a component, updated by a system.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GodotNode {
    node_ref: Ref&lt;Node2D&gt;,
}

fn update_position(node: &amp;GodotNode) {
    let pos = Vector2::new(20, 30);
  
    // fetch temporary reference to the node
    let node: TRef&lt;Node2D&gt; = unsafe { node.node_ref.assume_safe() };
    
    // call into the Godot engine
    // this implicitly invokes deref(), turning TRef&lt;Node2D&gt; into &amp;Node2D
    node.set_position(pos);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the parameter type is <code>&amp;GodotNode</code>, not <code>&amp;mut GodotNode</code>. Then why is it possible to mutate the Godot object?</p>
<p>All Godot classes in Rust (<code>Object</code> and its subtypes) have only methods that operate on <code>&amp;self</code>, not <code>&amp;mut self</code>. The reason for this choice is that <code>&amp;mut</code> is -- strictly speaking -- not a mutable reference, but rather an <a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html"><em>exclusive</em> reference</a>. The one and only thing it guarantees is that while it exists, no other reference to the same object can exist (no aliasing). Since all the Godot classes can be shared with the Godot engine, which is written in C++ and allows free aliasing, using <code>&amp;mut</code> references would potentially violate the exclusivity, leading to UB. This is why <code>&amp;T</code> is used, and just like e.g. <code>&amp;RefCell</code> it <em>does</em> allow mutation.</p>
<p>This being said, it can still make sense to bring back some type safety on a higher level in your own code. For example, you could make the <code>update_position()</code> take a <code>&amp;mut GodotNode</code> parameter, to make sure that access to this <code>GodotNode</code> object is exclusive.</p>
<p><em>See <code>TRef</code> in
<a href="https://docs.rs/gdnative/latest/gdnative/struct.TRef.html">godot-rust docs</a></em></p>
<h2 id="instance-reference-with-attached-rust-class"><a class="header" href="#instance-reference-with-attached-rust-class"><code>Instance</code>: reference with attached Rust class</a></h2>
<p>When working with classes that are provided by the engine or defined in GDScript, the <code>Ref</code> smart pointer is the ideal type for interfacing between Rust and Godot. However, when defining a custom class in Rust, that is registered with the Godot engine, there are two parts that need to be stored together:</p>
<ol>
<li><strong>GDNative script:</strong> the Rust struct object that implements the entire custom logic. The Rust struct is written by you.</li>
<li><strong>Base object:</strong> the base class from which the script inherits, with its own state. This is always a Godot built-in class such as <code>Object</code>, <code>Reference</code> or <code>Node</code>.</li>
</ol>
<p>The <code>Instance</code> class simply wraps the two parts into a single type.</p>
<p>When passing around your own Rust types, you will thus be working with <code>Instance</code>. The traits <code>ToVariant</code>, <code>FromVariant</code> and <code>OwnedToVariant</code> are automatically implemented for <code>Instance</code> types, allowing you to pass them from and to the Godot engine.</p>
<h3 id="construction"><a class="header" href="#construction">Construction</a></h3>
<p>Let's use a straightforward example: a player with name and score. Exported methods and properties are omitted for simplicity; the full interfacing will be explained later in <a href="gdnative-overview/../rust-binding/calling-gdscript.html">Calling into GDScript from Rust</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
// no #[inherit], thus inherits Reference by default
pub struct Player {
    name: String,
    score: u32,
}

#[methods]
impl Player {
    fn new(_owner: &amp;Reference) -&gt; Self {
        Self {
            name: &quot;New player&quot;.to_string(),
            score: 0
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To create a default instance, use <code>Instance::new_instance()</code>.<br />
You can later use <code>map()</code> and <code>map_mut()</code> to access the <code>Instance</code> immutably and mutably.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instance: Instance&lt;Reference, Unique&gt; = Instance::new();
// or:
let instance = Player::new_instance();

// note: map_mut() takes &amp;self, so above is not 'let mut'
instance.map_mut(|p: &amp;mut Player, _base: TRef&lt;Reference, Unique&gt;| {
    p.name = &quot;Joe&quot;.to_string();
    p.score = 120;
});
<span class="boring">}
</span></code></pre></pre>
<p>If you don't need a Godot-enabled default constructor, use the <code>#[no_constructor]</code> attribute and define your own Rust <code>new()</code> constructor.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[no_constructor]
pub struct Player {
    name: String,
    score: u32,
}

#[methods]
impl Player {
    pub fn new(name: &amp;str, score: u32) -&gt; Self {
       Self { name: name.to_string(), score }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, you can construct an <code>Instance</code> from an existing Rust object using <code>Instance::emplace()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let player = Player::new(&quot;Joe&quot;, 120);

let instance = Instance::emplace(player);
// or:
let instance = player.emplace();
<span class="boring">}
</span></code></pre></pre>
<p><em>See <code>Instance</code> in
<a href="https://docs.rs/gdnative/latest/gdnative/nativescript/struct.Instance.html">godot-rust docs</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-architecture"><a class="header" href="#game-architecture">Game architecture</a></h1>
<p><em>This chapter assumes that you are developing a game with Godot and Rust; however, many of the points apply to other projects like simulations or visualizations.</em></p>
<p>For users new to the godot-rust binding, there are a few questions that almost always come up:</p>
<ul>
<li>How do I organize my Rust code the best way?</li>
<li>Should I still use GDScript or do everything in Rust?</li>
<li>Where should I write my game logic?</li>
<li>How can I use the Godot scene tree, if Rust has no inheritance?</li>
</ul>
<p>Regarding architecture, godot-rust offers a lot of freedom and does not force you into certain patterns. How much you want to develop in GDScript and how much in Rust, is entirely up to you. The choice may depend on your experience, the amount of existing code you already have in either language, the scope of your game or simply personal preference.</p>
<p>Each language has their own strengths and weaknesses:</p>
<ul>
<li><strong>GDScript</strong> is close to the engine, allows for very fast prototyping and integrates well with the editor. However, its type system is limited and refactoring is often manual. There is no dependency management.</li>
<li><strong>Rust</strong> focuses on type safety, performance and scalability, with mature tooling and ecosystem. The language is rather complex and enforces discipline, and Godot-related tasks tend to be more verbose.</li>
</ul>
<p>As a starting point, this chapter highlights three common patterns that have been successfully used with godot-rust. This does not mean you must adhere to any of them; depending upon your needs, hybrid solutions or entirely different designs are also worth considering. The three patterns are listed in ascending order with respect to complexity and scalability.</p>
<h2 id="1-godot-game--rust-module"><a class="header" href="#1-godot-game--rust-module">1. Godot game + Rust module</a></h2>
<p>In this architecture, you develop your game primarily in the Godot engine. Most of the game logic resides in GDScript, and the Godot editor is your tool of choice. </p>
<p>During development, you encounter a feature which you wish to develop in Rust while making it accessible to GDScript. Reasons may include:</p>
<ul>
<li>The code is performance-critical and GDScript is not fast enough.</li>
<li>There is a Rust-based library that you wish to use, for example pathfinding, AI, or physics.</li>
<li>You have a segment of your code with high complexity that is difficult to manage in GDScript.</li>
</ul>
<p>In this case, you can write a GDNative class in Rust, with an API that exposes precisely the functionality you need -- no more and no less. godot-rust is only needed at the interface with GDScript. There are no calls into Godot from your Rust code, only exported methods.</p>
<p><img src="gdnative-overview/img/rust-module.png" alt="Godot scene tree with GDScript, calling to an external Rust module" /></p>
<p>Pros:</p>
<ul>
<li>Very easy to get started, especially for existing Godot codebases.</li>
<li>You can fully benefit from Godot's scene graph and the tooling around it.</li>
<li>You can test the Rust functionality independently, without running Godot.</li>
</ul>
<p>Cons:</p>
<ul>
<li>As most of the game logic is in GDScript, your project will not benefit from Rust's features, type safety and refactoring capabilities.</li>
<li>Your game logic needs to fit Godot's scene graph model and you have little control about architecture.</li>
</ul>
<h2 id="2-godot-scene-tree--native-scripts"><a class="header" href="#2-godot-scene-tree--native-scripts">2. Godot scene tree + native scripts</a></h2>
<p>The Godot engine encourages a certain pattern: each game entity is represented by a scene node, and the logic for each node is implemented in a GDScript file. You can follow the same architecture with godot-rust, the only difference being that scripts are implemented in Rust.</p>
<p>Instead of <code>.gd</code> script files, you use <code>.rs</code> files to implement native scripts, and you register native classes in <code>.gdns</code> files. Each Rust script can call into Godot to interact with other nodes, set up or invoke signals, query engine state, etc. Godot types have an equivalent representation in Rust, and the <code>Object</code> hierarchy is emulated in Rust via <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.Node.html#impl-Deref"><code>Deref</code></a> trait -- this means that e.g. <code>Node2D</code> references can be used to invoke methods on their parent class <code>Node</code>.</p>
<p>It often makes sense to be pragmatic and not try to do everything in Rust. For example, tweaking parameters for particle emitters or animation works much better in GDScript and/or the Godot editor.</p>
<p><img src="gdnative-overview/img/in-tree.png" alt="Rust NativeScripts directly inside the Godot tree" /></p>
<p>Pros:</p>
<ul>
<li>You can make full use of Godot's scene graph architecture while still writing the logic in Rust.</li>
<li>Existing code and concepts from GDScript can be carried over quite easily.</li>
</ul>
<p>Cons:</p>
<ul>
<li>You have little architectural freedom and are constrained by Godot's scene tree model.</li>
<li>As godot-rust is used throughout your entire codebase, this will tightly couple your game logic to Godot. Testing and isolating functionality can be harder and you are more subject to version changes of Godot and godot-rust.</li>
</ul>
<h2 id="3-rust-game--godot-io-layer"><a class="header" href="#3-rust-game--godot-io-layer">3. Rust game + Godot I/O layer</a></h2>
<p>This architecture is the counterpart to section 1. Most of your game is written in Rust, and you use the engine primarily for input/output handling. You can have an entry point to your Rust library (the <em>Controller</em>) which coordinates the simulation.</p>
<p>A typical workflow is as follows:</p>
<ol>
<li><strong>Input:</strong> You use the Godot engine to collect user input and events (key pressed, network packet arrived, timer elapsed, ...).</li>
<li><strong>Processing:</strong> The collected input is passed to Rust. The Controller runs a step in your game simulation and produces results.</li>
<li><strong>Output:</strong> These results are passed back to Godot and take effect in the scene (node positions, animations, sound effects, ...).</li>
</ol>
<p>If you follow this pattern strictly, the Godot scene graph can be entirely derived from your Rust state, as such it is only a visualization. There will be some GDScript glue code to tweak graphics/audio output.</p>
<p>This can be the most scalable and &quot;Rusty&quot; workflow, but it also requires a lot of discipline. Several interactions, which the other workflows offer for free, need to be implemented manually.</p>
<p><img src="gdnative-overview/img/rust-game.png" alt="Game in Rust, Godot scene tree with glue code in GDScript" /></p>
<p>Pros:</p>
<ul>
<li>You are completely free how you organize your Rust game logic. You can have your own entity hierarchy, use an ECS, or simply a few linear collections. </li>
<li>As your game logic runs purely in Rust, you don't need Godot to run the simulation. This allows for the following:
<ul>
<li>Rust-only headless server</li>
<li>Rust-only unit and integration tests</li>
<li>Different/simplified visualization backends</li>
</ul>
</li>
</ul>
<p>Cons:</p>
<ul>
<li>A robust design for your Rust architecture is a must, with considerable up-front work.</li>
<li>You need to manually synchronize your Rust entities with the Godot scene tree. In many cases, this means duplication of state in Rust (e.g. tile coordinate + health) and in Godot (world position + healthbar), as well as mapping between the two. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-to-rust-code"><a class="header" href="#binding-to-rust-code">Binding to Rust code</a></h1>
<p>This chapter provides an exhaustive list of mechanisms to pass data through the Rust GDNative binding, in both directions: </p>
<ul>
<li><strong>GDScript -&gt; Rust</strong>, e.g. to react to an input event with custom Rust logic</li>
<li><strong>Rust -&gt; GDScript</strong>, e.g. to apply a game logic change to a graphics node in Godot</li>
</ul>
<p>The goal is to serve as both an in-depth learning resource for newcomers and a reference to look up specific mechanisms at a later stage. Before delving into this chapter, make sure to read <a href="gdnative-overview.html">An Overview of GDNative</a>, which explains several fundamental concepts used here.</p>
<p>The subchapters are intended to be read in order, but you can navigate to them directly:</p>
<ol>
<li><a href="rust-binding/classes.html">Class registration</a></li>
<li><a href="rust-binding/methods.html">Exported methods</a></li>
<li><a href="rust-binding/properties.html">Exported properties</a></li>
<li><a href="./rust-binding/calling-gdscript.html">Calling into GDScript from Rust</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-registration"><a class="header" href="#class-registration">Class registration</a></h1>
<p>Classes are a fundamental data type of GDNative. They are used for Godot's own types (such as nodes) as well as custom ones defined by you. Here, we focus on defining <em>custom</em> classes and exposing them to Godot.</p>
<h2 id="the-rust-entry-point"><a class="header" href="#the-rust-entry-point">The Rust entry point</a></h2>
<p>When working with godot-rust, your Rust code sits inside a dynamic library with C ABI (<code>cdylib</code>), which is loaded at runtime from the Godot engine. The engine works as the host application with the entry and exit point, and your Rust code will be loaded at some point after Godot starts and unloaded before it ends.</p>
<p>This workflow implies that when you want to execute Rust code, you need to first pass control from Godot to it. To achieve this, every godot-rust application integrated with the engine must expose a public interface, through which Godot can invoke Rust code.</p>
<p>Somewhere in your code, usually in <code>lib.rs</code>, you need to declare the functions that will be called by the engine when the native library is loaded and unloaded, as well as the registration function for native classes exposed to the engine. godot-rust provides the following macros (consult <a href="https://docs.rs/gdnative/latest/gdnative/index.html#macros">their documentation</a> for further info and customization):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>godot_gdnative_init!();
godot_nativescript_init!(init);
godot_gdnative_terminate!();
<span class="boring">}
</span></code></pre></pre>
<p>Or the equivalent short-hand:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>godot_init!(init);
<span class="boring">}
</span></code></pre></pre>
<p>The argument <code>init</code> refers to the function registering native script classes, which is also defined by you. For this chapter, let's assume you want to write a class <code>GodotApi</code>, which exposes a public interface to be invoked from Godot. The registration is then as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// see details later
struct GodotApi { ... }

fn init(handle: InitHandle) {
    handle.add_class::&lt;GodotApi&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="class-definition"><a class="header" href="#class-definition">Class definition</a></h2>
<p>Similar to the <a href="rust-binding/../getting-started/hello-world.html#overriding-a-godot-method">Hello World</a> example, we can define the <code>GodotApi</code> native class as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Tell godot-rust that this struct is exported as a native class 
// (implements NativeClass trait)
#[derive(NativeClass)]

// Specify the base class (corresponds to 'extends' statement in GDScript).
// * Like 'extends' in GDScript, this can be omitted. 
//   In that case, the 'Reference' class is used as a base.
// * Unlike 'extends' however, only existing Godot types are permitted,
//   no other user-defined scripts.
#[inherit(Node)]
pub struct GodotApi {}

// Exactly one impl block can have the #[methods] annotation, 
// which registers methods in the background.
#[methods]
impl GodotApi {
    // Constructor, either:
    fn new(owner: &amp;Node) -&gt; Self { ... }
    // or:
    fn new(owner: TRef&lt;Node&gt;) -&gt; Self { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://docs.rs/gdnative/latest/gdnative/derive.NativeClass.html"><code>#[derive(NativeClass)]</code> macro</a> enables a Rust type to be usable as a <em>native class</em> in Godot. It implements <a href="https://docs.rs/gdnative/latest/gdnative/nativescript/trait.NativeClass.html">the <code>NativeClass</code> trait</a>, which fills in the glue code required to make the class available in Godot. Among other information, this includes class name and registry of exported methods and properties. For the user, the utility methods <code>new_instance()</code> and <code>emplace()</code> are provided for constructing <code>Instance</code> objects.</p>
<p>The function <code>new()</code> corresponds to <code>_init()</code> in GDScript. The <em>owner</em> is the base object of the script, and must correspond to the class specified in the <code>#[inherit]</code> attribute (or <code>Reference</code> if the attribute is absent). The parameter can be a shared reference <code>&amp;T</code> or a <code>TRef&lt;T&gt;</code>.</p>
<p>With a <code>new()</code> method, you are able to write <code>GodotApi.new()</code> in GDScript. If you don't need this, you can add the <code>#[no_constructor]</code> attribute to the struct declaration.</p>
<p>At this point, arguments cannot be passed into the constructor. Consult <a href="rust-binding/../faq.html#passing-additional-arguments-to-a-class-constructor">this FAQ entry</a> for available workarounds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exported-methods"><a class="header" href="#exported-methods">Exported methods</a></h1>
<p>In order to receive data from Godot, you can export methods. With the <code>#[export]</code> attribute, godot-rust takes care of method registration and serialization. Note that the constructor is not annotated with <code>#[export]</code>.</p>
<blockquote>
<h4 id="upcoming-api-changes"><a class="header" href="#upcoming-api-changes">Upcoming API changes</a></h4>
<p><code>#[export]</code> is being renamed as <code>#[godot]</code> and will soon be deprecated, and later removed in godot-rust 0.11.</p>
<p>For more information, see <a href="https://godot-rust.github.io/docs/gdnative/derive/derive.NativeClass.html"><code>gdnative::derive::NativeClass</code></a>.</p>
</blockquote>
<p>The exported method's first parameter is always <code>&amp;self</code> or <code>&amp;mut self</code> (operating on the Rust object), and the second parameter is <code>&amp;T</code> or <code>TRef&lt;T&gt;</code> (operating on the Godot base object, with <code>T</code> being the inherited type).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
pub struct GodotApi {
    enemy_count: i32,
}

#[methods]
impl GodotApi {
    fn new(_owner: &amp;Node) -&gt; Self {
        // Print to both shell and Godot editor console
        godot_print!(&quot;_init()&quot;);
        Self { enemy_count: 0 }
    }
    
    #[export]
    fn create_enemy(
        &amp;mut self,
        _owner: &amp;Node,
        typ: String,
        pos: Vector2
    ) {
        godot_print!(&quot;create_enemy(): type '{}' at position {:?}&quot;, typ, pos);
        self.enemy_count += 1;
    }

    #[export]
    fn create_enemy2(
        &amp;mut self,
        _owner: &amp;Node,
        typ: GodotString,
        pos: Variant
    ) {
        godot_print!(&quot;create_enemy2(): type '{}' at position {:?}&quot;, typ, pos);
        self.enemy_count += 1;
    }

    #[export]
    fn count_enemies(&amp;self, _owner: &amp;Node) -&gt; i32 {
        self.enemy_count
    }  
}
<span class="boring">}
</span></code></pre></pre>
<p>The two creation methods are semantically equivalent, yet they demonstrate how godot-rust implicitly converts the values to the parameter types (unmarshalling). You could use <code>Variant</code> everywhere, however it is more type-safe and expressive to use specific types. The same applies to return types, you could use <code>Variant</code> instead of <code>i32</code>.
<code>GodotString</code> is the Godot engine string type, but it can be converted to standard <code>String</code>. To choose between the two, consult <a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.GodotString.html">the docs</a>.</p>
<p>In GDScript, you can then write this code:</p>
<pre><code class="language-python">var api = GodotApi.new()

api.create_enemy(&quot;Orc&quot;, Vector2(10, 20));
api.create_enemy2(&quot;Elf&quot;, Vector2(50, 70));

print(&quot;enemies: &quot;, api.count_enemies())

# don't forget to add it to the scene tree, otherwise memory must be managed manually 
self.add_child(api)
</code></pre>
<p>The output is:</p>
<pre><code>_init()
create_enemy(): type 'Orc' at position (10.0, 20.0)
create_enemy2(): type 'Elf' at position Vector2((50, 70))
enemies: 2
</code></pre>
<h2 id="passing-classes"><a class="header" href="#passing-classes">Passing classes</a></h2>
<p>The above examples have dealt with simple types such as strings and integers. What if we want to pass entire classes to Rust?</p>
<p>Let's say we want to pass in an enemy from GDScript, instead of creating one locally. It could be represented by the <code>Node2D</code> class and directly configured in the Godot editor. What you then would do is use <a href="rust-binding/../gdnative-overview/wrappers.html">the <code>Ref</code> wrapper</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
pub struct GodotApi {
    // Store references to all enemy nodes
    enemies: Vec&lt;Ref&lt;Node2D&gt;&gt;,
}

#[methods]
impl GodotApi {
    // new() etc...

    #[export]
    fn add_enemy(
        &amp;mut self,
        _owner: &amp;Node,
        enemy: Ref&lt;Node2D&gt; // pass in enemy
    ) {
        self.enemies.push(enemy);
    }
  
    // You can even return the enemies directly with Vec.
    // In GDScript, you will get an array of nodes.
    // An alternative would be VariantArray, able to hold different types.
    #[export]
    fn get_enemies(
        &amp;self,
        _owner: &amp;Node
    ) -&gt;  Vec&lt;Ref&lt;Node2D&gt;&gt; {
        self.enemies.clone()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="special-methods"><a class="header" href="#special-methods">Special methods</a></h2>
<p>Godot offers some special methods. Most of them implement <a href="https://docs.godotengine.org/en/stable/getting_started/workflow/best_practices/godot_notifications.html">notifications</a>, i.e. callbacks from the engine to notify the class about a change.</p>
<p>If you need to override a Godot special method, just declare it as a normal exported method, with the same name and signature as in GDScript:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn _ready(&amp;mut self, _owner: &amp;Node) {...}

#[export]
fn _process(&amp;mut self, _owner: &amp;Node, delta: f32) {...}

#[export]
fn _physics_process(&amp;mut self, _owner: &amp;Node, delta: f32) {...}
<span class="boring">}
</span></code></pre></pre>
<p>If you want to change how GDScript's default formatter in functions like <code>str()</code> or <code>print()</code> works, you can overload the <code>to_string</code> GDScript method, which corresponds to the following Rust method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn _to_string(&amp;self, _owner: &amp;Reference) -&gt; String {...}
<span class="boring">}
</span></code></pre></pre>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>If you pass arguments from GDScript that are incompatible with the Rust method's signature, the method invocation will fail. In this case, the code inside the method is not executed. An error message is printed on the Godot console, and the value <code>null</code> is returned for the GDScript function call.</p>
<p>If code inside your method panics (e.g. by calling <code>unwrap()</code> on an empty option/result), the same happens: error message and return value <code>null</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exported-properties"><a class="header" href="#exported-properties">Exported properties</a></h1>
<p>Like methods, properties can be exported. The <code>#[property]</code> attribute above a field declaration makes the field available to Godot, with its name and type.</p>
<p>In the previous example, we could replace the <code>count_enemies()</code> method with a property <code>enemy_count</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
pub struct GodotApi {
    #[property]
    enemy_count: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>The GDScript code would be changed as follows.</p>
<pre><code class="language-python">print(&quot;enemies: &quot;, api.enemy_count)
</code></pre>
<p>That's it.</p>
<h2 id="export-options"><a class="header" href="#export-options">Export options</a></h2>
<p>The <code>#[property]</code> attribute can accept a several options to refine the export behavior.</p>
<p>You can specify default property value with the following argument:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[property(default = 10)]
enemy_count: i32,
<span class="boring">}
</span></code></pre></pre>
<p>If you need to hide this property in Godot editor, use <code>no_editor</code> option:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[property(no_editor)]
enemy_count: i32,
<span class="boring">}
</span></code></pre></pre>
<h2 id="property-access-hooks"><a class="header" href="#property-access-hooks">Property access hooks</a></h2>
<p>You can add hooks to call methods before and after property value was retrieved or changed.</p>
<p>Note that unlike <a href="https://docs.godotengine.org/en/3.3/getting_started/scripting/gdscript/gdscript_basics.html?#setters-getters">GDScript's <code>setget</code> keyword</a>, this does <em>not</em> register a custom setter or getter. Instead, it registers a callback which is invoked <em>before or after</em> the set/get occurs, and lacks both parameter and return value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Default)]
#[inherit(Node)]
struct GodotApi {
    // before get
    #[property(before_get = &quot;Self::before_get&quot;)]
    prop_before_get: i32,

    // before set
    #[property(before_set = &quot;Self::before_set&quot;)]
    prop_before_set: i32,

    // after get
    #[property(after_get = &quot;Self::after_get&quot;)]
    prop_after_get: i32,

    // after set
    #[property(after_set = &quot;Self::after_set&quot;)]
    prop_after_set: i32,
}

impl GodotApi {
    fn new(_owner: &amp;Node) -&gt; Self {
        Self::default()
    }

    fn before_get(&amp;self, _owner: TRef&lt;Node&gt;) {
        godot_print!(&quot;Before get&quot;);
    }

    fn before_set(&amp;self, _owner: TRef&lt;Node&gt;) {
        godot_print!(&quot;Before set&quot;);
    }

    fn after_get(&amp;self, _owner: TRef&lt;Node&gt;) {
        godot_print!(&quot;After get&quot;);
    }

    fn after_set(&amp;self, _owner: TRef&lt;Node&gt;) {
        godot_print!(&quot;After set&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="manual-property-registration"><a class="header" href="#manual-property-registration">Manual property registration</a></h2>
<p>For cases not covered by the <code>#[property]</code> attribute, it may be necessary to manually register the properties instead.</p>
<p>This is often the case where custom hint behavior is desired for primitive types, such as an Integer value including an <code>IntEnum</code> hint.</p>
<p>To do so, you can use the <a href="https://docs.rs/gdnative/latest/gdnative/prelude/struct.ClassBuilder.html"><code>ClassBuilder</code></a> -- such as in the following examples -- to manually register each property and customize how they interface in the editor.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(gdnative::api::Node)]
#[register_with(Self::register_properties)]
pub struct MyNode {
    number: i32,
    number_enum: i32,
    float_range: f32,
    my_filepath: String,
}

#[gdnative::methods]
impl MyNode {
    fn register_properties(builder: &amp;ClassBuilder&lt;MyNode&gt;) {
        use gdnative::nativescript::property::StringHint;
        // Add a number with a getter and setter. 
        // (This is the equivalent of adding the `#[property]` attribute for `number`)
        builder
            .add_property::&lt;i32&gt;(&quot;number&quot;)
            .with_getter(number_getter)
            .with_setter(numer_setter)
            .done();

        // Register the number as an Enum
        builder
            .add_property::&lt;i32&gt;(&quot;number_enum&quot;)
            .with_getter(move |my_node: &amp;MyNode, _owner: TRef&lt;Node&gt;| my_node.number_enum)
            .with_setter(move |my_node: &amp;mut MyNode, _owner: TRef&lt;Node&gt;, new_value| my_node.number_enum = new_value)
            .with_default(1)
            .with_hint(IntHint::Enum(EnumHint::new(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))
            .done();

        // Register a floating point value with a range from 0.0 to 100.0 with a step of 0.1
        builder
            .add_property::&lt;f64&gt;(&quot;float_range&quot;)
            .with_getter(move |my_node: &amp;MyNode, _owner: TRef&lt;Node&gt;| my_node.float_range)
            .with_setter(move |my_node: &amp;mut MyNode, _owner: TRef&lt;Node&gt;, new_value| my_node.float_range = new_value)
            .with_default(1.0)
            .with_hint(FloatHint::Range(RangeHint::new(0.0, 100.0).with_step(0.1)))
            .done();

        // Manually register a string as a file path for .txt and .dat files.
        builder
            .add_property::&lt;String&gt;(&quot;my_filepath&quot;)
            .with_getter(move |my_node: &amp;MyNode, _owner: TRef&lt;Node&gt;| my_node.my_filepath.clone())
            .with_setter(move |my_node: &amp;mut MyNode, _owner: TRef&lt;Node&gt;, new_value: String| my_node.my_filepath = new_value)
            .with_default(&quot;&quot;.to_owned())
            .with_hint(StringHint::File(EnumHint::new(vec![&quot;*.txt&quot;.to_owned(), &quot;*.dat&quot;.to_owned()])))
            .done();
    }
    fn number_getter(&amp;self, _owner: TRef&lt;Node&gt;) -&gt; i32 {
        self.number
    }

    fn number_setter(&amp;mut self, _owner: TRef&lt;Node&gt;, new_value: i32) {
        self.number = new_value
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tovariant-fromvariant-and-export"><a class="header" href="#tovariant-fromvariant-and-export">ToVariant, FromVariant and Export</a></h1>
<p>As seen in <a href="rust-binding/./properties.html">the previous section</a>, the <code>#[property]</code> attribute of the <a href="https://docs.rs/gdnative/latest/gdnative/derive.NativeClass.html"><code>NativeClass</code></a> procedural macro is a powerful tool to automatically configure properties with Godot.</p>
<p>One constraint of the <code>#[property]</code> attribute is that it requires that all attributed property types implement <code>ToVariant</code>, <code>FromVariant</code> and <code>Export</code> in order to interface with Godot.</p>
<h2 id="tovariantfromvariant-traits"><a class="header" href="#tovariantfromvariant-traits">ToVariant/FromVariant traits</a></h2>
<p>In Godot all types inherit from Variant.</p>
<p>As per the <a href="https://docs.godotengine.org/en/stable/classes/class_variant.html">official Godot docs</a>, Variant is &quot;The most important data type in Godot.&quot; This is a wrapper type that can store any <a href="https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html#enum-globalscope-variant-type">Godot Engine type</a></p>
<p>The <code>ToVariant</code> and <code>FromVariant</code> are conversion traits that allow Rust types to be converted between these types. All properties must implement both <code>ToVariant</code> and <code>FromVariant</code> while exported methods require <code>FromVariant</code> to be implemented for optional parameters and <code>ToVariant</code> to be implemented for return types.</p>
<p>For many datatypes, it is possible to use the derive macros such as in the following example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: This struct does not implement `Export` and cannot be used as a property, see the following section for more information.
#[derive(ToVariant, FromVariant)]
struct Foo {
    number: i32,
    float: f32,
    string: String
}
<span class="boring">}
</span></code></pre></pre>
<p>For more information about how you can customize the behavior of the dervive macros, please refer to the official documentation for the latest information.</p>
<ul>
<li><a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.ToVariant.html">ToVariant</a></li>
<li><a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.FromVariant.html">FromVariant</a></li>
</ul>
<h2 id="export-trait"><a class="header" href="#export-trait">Export Trait</a></h2>
<p>The Godot editor retrieves property information from <a href="https://docs.godotengine.org/en/stable/classes/class_object.html#id2">Object::get_property_list</a>. To populate this data, <code>godot-rust</code> requires that the <a href="https://docs.rs/gdnative/latest/gdnative/nativescript/trait.Export.html"><code>Export</code></a> trait be implemented for each type Rust struct.</p>
<p>There are no derive macros that can be used for <code>Export</code> but many of the primitive types have it implemented by default.</p>
<p>To implement <code>Export</code> for the previous Rust data type, you can do so as in the following example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: By default `struct` will be converted to and from a Dictionary where property corresponds to a key-value pair.
#[derive(ToVariant, FromVariant)]
struct Foo {
    number: i32,
    float: f32,
    string: String
}

impl Export for Foo {
    // This type should normally be one of the types defined in [gdnative::export::hint](https://docs.rs/gdnative/latest/gdnative/export/hint/index.html).
    // Or it can be any custom type for differentiating the hint types.
    // In this case it is unused, so it is left as ()
    type Hint = ();
    fn export_info(hint: Option&lt;Self::Hint&gt;) -&gt; ExportInfo {
        // As `Foo` is a struct that will be converted to a Dictionary when converted to a variant, we can just add this as the VariantType.
        ExportInfo::new(VariantType::Dictionary)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="case-study-exporting-rust-enums-to-godot-and-back"><a class="header" href="#case-study-exporting-rust-enums-to-godot-and-back">Case study: exporting Rust enums to Godot and back</a></h2>
<p>A common challenge that many developers may encounter when using godot-rust is that while <a href="https://doc.rust-lang.org/std/keyword.enum.html">Rust enums</a> are <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic Data Types</a>, <a href="https://docs.godotengine.org/en/stable/getting_started/scripting/gdscript/gdscript_basics.html#enums">Godot enums</a> are constants that correspond to integer types.</p>
<p>By default, Rust enums are converted to a Dictionary representation. Its keys correspond to the name of the enum variants, while the values correspond to a Dictionary with fields as key-value pairs.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(ToVariant, FromVariant)]
enum MyEnum {
    A,
    B { inner: i32 },
    C { inner: String }
}
<span class="boring">}
</span></code></pre></pre>
<p>Will convert to the following dictionary:</p>
<pre><code class="language-gdscript"># MyEnum::A
&quot;{ &quot;A&quot;: {} }
# MyEnum::B { inner: 0 }
{ &quot;B&quot;: { &quot;inner&quot;: 0 } }
# MyEnum::C { inner: &quot;value&quot; }
{ &quot;C&quot;: {&quot;inner&quot;: &quot;value&quot; } }
</code></pre>
<p>As of writing (gdnative 0.9.3), this default case is not configurable. If you want different behavior, it is necessary to implement <code>FromVariant</code> and <code>Export</code> manually for this data-type.</p>
<h3 id="case-1-rust-enum---godot-enum"><a class="header" href="#case-1-rust-enum---godot-enum">Case 1: Rust Enum -&gt; Godot Enum</a></h3>
<p>Consider the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyIntEnum {
    A=0, B=1, C=2,
}

#[derive(NativeClass)]
#[inherit(Node)]
#[no_constructor]
struct MyNode {
    #[export]
    int_enum: MyIntEnum
}
<span class="boring">}
</span></code></pre></pre>
<p>This code defines the enum <code>MyIntEnum</code>, where each enum value refers to an integer value.</p>
<p>Without implementing the <code>FromVariant</code> and <code>Export</code> traits, attempting to export <code>MyIntEnum</code> as a property of <code>MyNode</code> will result in the following error:</p>
<pre><code class="language-sh">the trait bound `MyIntEnum: gdnative::prelude::FromVariant` is not satisfied
   required because of the requirements on the impl of `property::accessor::RawSetter&lt;MyNode, MyIntEnum&gt;` for `property::accessor::invalid::InvalidSetter&lt;'_&gt;`2

the trait bound `MyIntEnum: Export` is not satisfied
    the trait `Export` is not implemented for `MyIntEnum`
</code></pre>
<p>This indicates that <code>MyIntEnum</code> does not have the necessary traits implemented for <code>FromVariant</code> and <code>Export</code>. Since the default derived behavior may not be quite what we want, we can implement this with the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromVariant for MyIntEnum {
    fn from_variant(variant: &amp;Variant) -&gt; Result&lt;Self, FromVariantError&gt; {
        let result = i64::from_variant(variant)?;
        match result {
            0 =&gt; Ok(MyIntEnum::A),
            1 =&gt; Ok(MyIntEnum::B),
            2 =&gt; Ok(MyIntEnum::C),
            _ =&gt; Err(FromVariantError::UnknownEnumVariant {
                variant: &quot;i64&quot;.to_owned(),
                expected: &amp;[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],
            }),
        }
    }
}

impl Export for MyIntEnum {
    type Hint = IntHint&lt;u32&gt;;

    fn export_info(_hint: Option&lt;Self::Hint&gt;) -&gt; ExportInfo {
        Self::Hint::Enum(EnumHint::new(vec![
            &quot;A&quot;.to_owned(),
            &quot;B&quot;.to_owned(),
            &quot;C&quot;.to_owned(),
        ]))
        .export_info()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>After implementing <code>FromVariant</code> and <code>Export</code>, running cargo check wouuld result in the following additional error:</p>
<pre><code class="language-sh">the trait bound `MyIntEnum: gdnative::prelude::ToVariant` is not satisfied
the trait `gdnative::prelude::ToVariant` is not implemented for `MyIntEnum`
</code></pre>
<p>If the default implementation were sufficient, we could use <code>#[derive(ToVariant)]</code> for <code>MyIntEnum</code> or implement it manually with the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::core_types::ToVariant;
impl ToVariant for MyIntEnum {
    fn to_variant(&amp;self) -&gt; Variant {
        match self {
            MyIntEnum::A =&gt; { 0.to_variant() },
            MyIntEnum::B =&gt; { 1.to_variant() },
            MyIntEnum::C =&gt; { 2.to_variant() },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>At this point, there should be no problem in using <code>MyIntEnum</code> as a property in your native class that is exported to the editor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-gdscript-from-rust"><a class="header" href="#calling-gdscript-from-rust">Calling GDScript from Rust</a></h1>
<p>To transport information from Rust back to GDScript, you have three options (of which the last can be achieved in different ways):</p>
<ul>
<li>Use return values in exported methods</li>
<li>Use exported properties</li>
<li>Call a Godot class method from Rust
<ul>
<li>invoke built-in method as part of the API (e.g. <code>set_position()</code> above)</li>
<li>invoke custom GDScript method, through <code>call()</code> and overloads</li>
<li>emit a signal, through <code>emit_signal()</code></li>
</ul>
</li>
</ul>
<p>Which one you need depends on your goals and your architecture. If you see Rust as a deterministic, functional machine in the sense of <em>input -&gt; processing -&gt; output</em>, you could stick to only returning data from Rust methods, and never directly calling a Godot method. This can be limiting however, and depending on your use case you end up manually dispatching back to different nodes on the GDScript side.</p>
<h2 id="passing-custom-classes-to-gdscript"><a class="header" href="#passing-custom-classes-to-gdscript">Passing custom classes to GDScript</a></h2>
<p>On the previous pages, we explained how to export a class, so it can be instantiated and called from GDScript. This section explains how to construct a class locally in Rust.</p>
<p>Let's define a class <code>Enemy</code> which acts as a simple data bundle, i.e. no functionality. We inherit it from <code>Reference</code>, such that memory is managed automatically. In addition, we define <code>_to_string()</code> and delegate it to the derived <code>Debug</code> trait implementation, to make it printable from GDScript.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Debug)]
// no #[inherit], thus inherits Reference by default
#[no_constructor]
pub struct Enemy {
    #[property]
    pos: Vector2,

    #[property]
    health: f32,

    #[property]
    name: String,
}

#[methods]
impl Enemy {
    #[export]
    fn _to_string(&amp;self, _owner: &amp;Reference) -&gt; String {
        format!(&quot;{:?}&quot;, self) // calls Debug::fmt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Godot can only use classes that are registered, so let's do that:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init(handle: InitHandle) {
    // ...
    handle.add_class::&lt;Enemy&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, it's not possible to directly return <code>Enemy</code> instances in exported methods, so this won't work:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn create_enemy(&amp;mut self, _owner: &amp;Node) -&gt; Enemy {...}
<span class="boring">}
</span></code></pre></pre>
<p>Instead, you can wrap the object in a <code>Instance&lt;Enemy, Unique&gt;</code>, using <code>emplace()</code>. For an in-depth explanation of the <code>Instance</code> class, read <a href="rust-binding/../gdnative-overview/wrappers.html#instance-reference-with-attached-rust-class">this section</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn create_enemy(
    &amp;self,
    _owner: &amp;Node
) -&gt; Instance&lt;Enemy, Unique&gt; {
    let enemy = Enemy {
        pos: Vector2::new(7.0, 2.0),
        health: 100.0,
        name: &quot;MyEnemy&quot;.to_string(),
    };
    
    enemy.emplace()
}
<span class="boring">}
</span></code></pre></pre>
<p>When calling this method in GDScript:</p>
<pre><code class="language-python">var api = GodotApi.new()
var enemy = api.create_enemy()
print(&quot;Enemy created: &quot;, enemy)
</code></pre>
<p>the output will be:</p>
<pre><code>Enemy created: Enemy { pos: (7.0, 2.0), health: 100.0, name: &quot;MyEnemy&quot; }
</code></pre>
<p>If you want types to be default-constructible, e.g. to allow construction from GDScript, omit the <code>#[no_constructor]</code> attribute. You can default-construct from Rust using <code>Instance::new_instance()</code>.</p>
<h2 id="function-calls"><a class="header" href="#function-calls">Function calls</a></h2>
<p>While you can export Rust methods to be called from GDScript, the opposite is also possible. Typical use cases for this include:</p>
<ul>
<li>Read or modify the scene tree directly from Rust (e.g. moving a node)</li>
<li>Synchronizing logic state (Rust) with visual representation (Godot)</li>
<li>Notify code in GDScript about changes in Rust</li>
</ul>
<p>Methods provided by Godot classes are mapped to regular Rust functions. Examples for these are <code>Node2D::rotate()</code>, <code>Button::set_text()</code>, <code>StaticBody::bounce()</code>. They can usually be invoked safely on a <code>&amp;T</code> or <code>TRef&lt;T&gt;</code> reference to the respective object.</p>
<p>Custom GDScript methods (defined in .gd files) on the other hand need to be invoked dynamically. This means that there is no type-safe Rust signature, so you will use the <code>Variant</code> type. All Godot-compatible types can be converted to variants. For the actual call, <code>Object</code> provides multiple methods. Since every Godot class eventually dereferences to <code>Object</code>, you can invoke them on any Godot class object.</p>
<p>The following GDScript method:</p>
<pre><code class="language-python"># in UserInterface.gd
extends CanvasItem

func update_stats(mission_name: String, health: float, score: int) -&gt; bool:
    # ...
</code></pre>
<p>can be invoked from Rust as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::core_types::ToVariant;

fn update_mission_ui(ui_node: Ref&lt;CanvasItem&gt;) {
    let mission_name = &quot;Thunderstorm&quot;.to_variant();
    let health = 37.2.to_variant();
    let score = 140.to_variant();

    // both assume_safe() and call() are unsafe
    let node: TRef&lt;CanvasItem&gt; = unsafe { ui_node.assume_safe() };
    let result: Variant = unsafe {
        node.call(&quot;update_stats&quot;, &amp;[mission_name, health, score])
    };
  
    let success: bool = result.try_to_bool().expect(&quot;returns bool&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Besides <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.Object.html#method.call"><code>Object::call()</code></a>, alternative methods <code>callv()</code> (accepting a <code>VariantArray</code>) and <code>call_deferred()</code> (calling the next frame) exist, but the principle stays the same.</p>
<p>For long parameter lists, it often makes sense to bundle related functionality into a new class, let's say <code>Stats</code> in the above example. When working with classes, you can convert both <code>Ref</code> (for Godot/GDScript classes) and <code>Instance</code> (for native classes) to <code>Variant</code> by means of the <code>OwnedToVariant</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::core_types::OwnedToVariant; // owned_to_variant()
use gdnative::nativescript::NativeClass; // emplace()

// Native class bundling the update information
#[derive(NativeClass)]
#[no_constructor]
struct Stats {
    #[property]
    mission_name: String,
  
    #[property]
    health: f32,
  
    #[property]
    score: i32,
}

fn update_mission_ui(ui_node: Ref&lt;CanvasItem&gt;) {
    let stats = Stats {
        mission_name: &quot;Thunderstorm&quot;.to_variant(),
        health: 37.2.to_variant(),
        score: 140.to_variant(),      
    };
  
    let instance: Instance&lt;Stats, Unique&gt; = stats.emplace();
    let variant: Variant = instance.owned_to_variant();

    let node: TRef&lt;CanvasItem&gt; = unsafe { ui_node.assume_safe() };
    
    // let's say the method now returns a Stats object with previous stats
    let result: Variant = unsafe { node.call(&quot;update_stats&quot;, &amp;[variant]) };
  
    // convert Variant -&gt; Ref -&gt; Instance
    let base_obj: Ref&lt;Reference&gt; = result.try_to_object().expect(&quot;is Reference&quot;);
    let instance: Instance&lt;Stats, Shared&gt; = Instance::from_base(base_obj).unwrap();
    
    instance.map(|prev_stats: &amp;Stats, _base| {
        // read prev_stats here
    });
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="warning"><a class="header" href="#warning">Warning</a></h3>
<p>When calling GDScript functions from Rust, a few things need to be kept in mind.</p>
<p><strong>Safety:</strong> Since the calls are dynamic, it is possible to invoke any other functions through them, including unsafe ones like <code>free()</code>. As a result, <code>call()</code> and its alternatives are unsafe.</p>
<p><strong>Re-entrancy:</strong> When calling from Rust to GDScript, your Rust code is usually already running in an exported <code>#[export]</code> method, meaning that it has bound its receiver object via <code>&amp;T</code> or <code>&amp;mut T</code> reference. In the GDScript code, you must not invoke any method on the same Rust receiver, which would violate safety rules (aliasing of <code>&amp;mut</code>).</p>
<h2 id="signal-emissions"><a class="header" href="#signal-emissions">Signal emissions</a></h2>
<p>Like methods, signals defined in GDScript can be emitted dynamically from Rust.</p>
<p>The mechanism works analogously to function invocation, except that you use <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.Object.html#method.emit_signal"><code>Object::emit_signal()</code></a> instead of <code>Object::call()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>This is a list of frequently asked questions that have been pulled from various sources. This will be periodically updated with new information.</p>
<p>Please select one of the categories in the side bar for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-common-code-questions"><a class="header" href="#faq-common-code-questions">FAQ: Common code questions</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="faq/code.html#how-do-i-store-a-reference-of-node">How do I store a reference of <code>Node</code>?</a></li>
<li><a href="faq/code.html#borrow-failed-a-mut-reference-was-requested">Borrow failed; a &amp;mut reference was requested</a></li>
<li><a href="faq/code.html#why-do-mutating-godot-methods-take-self-and-not-mut-self">Why do mutating Godot methods take <code>&amp;self</code> and not <code>&amp;mut self</code>?</a></li>
<li><a href="faq/code.html#why-is-there-so-much-unsafe-in-godot-rust">Why is there so much <code>unsafe</code> in godot-rust?</a></li>
<li><a href="faq/code.html#can-the-new-constructor-have-additional-parameters">Can the <code>new</code> constructor have additional parameters?</a></li>
<li><a href="faq/code.html#can-i-implement-static-methods-in-gdnative">Can I implement static methods in GDNative?</a></li>
<li><a href="faq/code.html#how-do-i-convert-from-a-variant-to-the-underlying-rust-type">How do I convert from a <code>Variant</code> to the underlying Rust type?</a></li>
<li><a href="faq/code.html#is-it-possible-to-set-subproperties-of-a-godot-type-such-as-a-material">Is it possible to set subproperties of a Godot type, such as a <code>Material</code>?</a></li>
<li><a href="faq/code.html#what-is-the-rust-equivalent-of-preload">What is the Rust equivalent of <code>preload</code>?</a></li>
<li><a href="faq/code.html#how-can-function-parameters-accept-godot-subclasses-polymorphism">How can function parameters accept Godot subclasses (polymorphism)?</a></li>
<li><a href="faq/code.html#what-is-the-rust-equivalent-of-onready-var">What is the Rust equivalent of <code>onready var</code>?</a></li>
<li><a href="faq/code.html#what-types-are-supported-for-passing-through-the-gdnative-api">What types are supported for passing through the GDNative API?</a></li>
<li><a href="faq/code.html#how-can-i-profile-my-code-to-measure-performance">How can I profile my code to measure performance?</a></li>
</ul>
<h2 id="how-do-i-store-a-reference-of-node"><a class="header" href="#how-do-i-store-a-reference-of-node">How do I store a reference of <code>Node</code>?</a></h2>
<p>The idiomatic way to maintain a reference to a node in the SceneTree from Rust is to use <code>Option&lt;Ref&lt;T&gt;&gt;</code>.</p>
<p>For example, the following GDScript code:</p>
<pre><code class="language-gdscript">extends Node
class_name MyClass
var node

func _ready():
  node = Node.new()
  self.add_child(node, false)

</code></pre>
<p>could be translated to this Rust snippet:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
#[no_constructor]
struct MyNode {
    node_ref: Option&lt;Ref&lt;Node&gt;&gt;
}

#[methods]
impl MyNode {
    #[export]
    fn _ready(&amp;self, owner: TRef&lt;Node&gt;) {
        let node = Node::new();
        owner.add_child(node);
        self.node_ref = Some(node.claim());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note: As <code>TRef&lt;T&gt;</code> is a temporary pointer, it will be necessary to get the base pointer <code>Ref&lt;T&gt;</code> in order to continue to hold this value.</p>
<p>This can be done with the <a href="https://docs.rs/gdnative/latest/gdnative/struct.TRef.html#method.claim"><code>TRef&lt;T&gt;::claim()</code></a> function that returns the persistent version of the pointer, which you can store in your class.</p>
<h2 id="borrow-failed-a-mut-reference-was-requested"><a class="header" href="#borrow-failed-a-mut-reference-was-requested">Borrow failed; a &amp;mut reference was requested</a></h2>
<p>In Rust, <a href="https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html">there can only be <em>one</em> <code>&amp;mut</code> reference to the same memory location at the same time</a>. To enforce this while making simple use cases easier, the bindings make use of <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>. This works like a lock: whenever a method with <code>&amp;mut self</code> is called, it will try to obtain a lock on the <code>self</code> value, and hold it <em>until it returns</em>. As a result, if another method that takes <code>&amp;mut self</code> is called in the meantime for whatever reason (e.g. signals), the lock will fail and an error (<code>BorrowFailed</code>) will be produced.</p>
<p>It's relatively easy to work around this problem, though: Because of how the user-data container works, it can only see the outermost layer of your script type - the entire structure. This is why it's stricter than what is actually required. If you run into this problem, you can <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">introduce finer-grained interior mutability</a> in your own type, and modify the problematic exported methods to take <code>&amp;self</code> instead of <code>&amp;mut self</code>.</p>
<p>This issue also can often occur when using signals to indicate an update such as in the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
// register_with attribute can be used to specify custom register function for node signals and properties
#[register_with(Self::register_signals)]
struct SignalEmitter {
    data: LargeData,
}

#[methods]
impl SignalEmitter {
    fn register_signals(builder: &amp;ClassBuilder&lt;Self&gt;) {
        builder.add_signal(Signal { name: &quot;updated&quot;, args: &amp;[] });
    }

    fn new(_owner: &amp;Node) -&gt; Self {
        SignalEmitter {
            data: &quot;initial&quot;,
        }
    }
    #[export]
    fn update_data(&amp;mut self, owner: TRef&lt;Node&gt;, data: LargeData) {
        self.data = data;
        owner.emit_signal(&quot;updated&quot;, &amp;[]);
    }
    #[export]
    fn get_data(&amp;self, owner: TRef&lt;Node&gt;) -&gt; &amp;LargeData {
        &amp;self.data
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The assumption with the above code is that <code>SignalEmitter</code> is holding data that is too large to be feasible to clone into the signal. So the purpose of the signal is to notify other Nodes or Objects that this the data has been updated.</p>
<p>The problem is that, unless the nodes all connect with the <code>Object::CONNECT_DEFERRED</code> flag, they will be notified immediately and will attempt to borrow the data. This is the root cause of the <code>BorrowFailed</code> error.</p>
<p>There are two ways to solve it.</p>
<ol>
<li>Ensure that all nodes use <code>Object::CONNECT_DEFERRED</code> since this will ensure that the callbacks wait until the idle_frame signal to borrow the data.</li>
<li>Store <code>data</code> in a <code>RefCell&lt;LargeData&gt;</code> if it should only be accessed from the same thread (such as with signals) or <code>Mutex&lt;LargeData&gt;</code> if you need thread-safety. Then you can modify <code>update_data()</code> to the following snippet:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update_data(&amp;self, owner: TRef&lt;Node&gt;, data: LargeData) {
        // If using RefCell
        self.data.replace(data);
        // If using Mutex
        // *self.data.lock().expect(&quot;this should work&quot;) = data;
        owner.emit_signal(&quot;updated&quot;, &amp;[]);
    }
<span class="boring">}
</span></code></pre></pre>
<p>In both instances you will not encounter the reentrant errors.</p>
<h2 id="why-do-mutating-godot-methods-take-self-and-not-mut-self"><a class="header" href="#why-do-mutating-godot-methods-take-self-and-not-mut-self">Why do mutating Godot methods take <code>&amp;self</code> and not <code>&amp;mut self</code>?</a></h2>
<ol>
<li><code>&amp;mut</code> means that only one reference can exist simultaneously (no aliasing), <em>not</em> that the object is mutable. Mutability is often a <em>consequence</em> of the exclusiveness. Since Godot objects are managed by the engine, Rust cannot guarantee that references are exclusive, as such using <code>&amp;mut</code> would cause undefined behavior. Instead, an interior mutability pattern based on <code>&amp;T</code> is used. For godot-rust, it is probably more useful to consider <code>&amp;</code> and <code>&amp;mut</code> as &quot;shared&quot; and &quot;unique&quot; respectively.
For more information, please refer to <a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html">this explanation</a> for more information.</li>
<li>Why godot-rust does not use <code>RefCell</code> (or some other form of interior mutability) is because the types already have interior mutability as they exist in Godot (and can't be tracked by Rust). For example, does <code>call()</code> modify its own object? This depends on the arguments. There are <a href="https://github.com/godot-rust/godot-rust/issues/808#issuecomment-964034258">many such cases</a> which are much more subtle.</li>
</ol>
<h2 id="why-is-there-so-much-unsafe-in-godot-rust"><a class="header" href="#why-is-there-so-much-unsafe-in-godot-rust">Why is there so much <code>unsafe</code> in godot-rust?</a></h2>
<p>Short Answer: Godot is written in C++, which cannot be statically analyzed by the Rust compiler to guarantee safety.</p>
<p>Longer Answer: <code>unsafe</code> is required for different reasons:</p>
<ul>
<li><strong>Object lifetimes:</strong> Godot manages memory of objects independently of Rust. This means that Rust references can be invalidated when Godot destroys referred-to objects. This usually happens due to bugs in GDScript code, like calling <code>free()</code> of something actively in use.</li>
<li><strong>Thread safety:</strong> while Rust has a type system to ensure thread safety statically (<code>Send</code>, <code>Sync</code>), such mechanisms do not exist in either GDScript or C++. Even user-defined GDScript code has direct access to the <code>Thread</code> API.</li>
<li><strong>C FFI:</strong> any interactions that cross the C Foreign Function Interface will be unsafe by default as Rust cannot inspect the other side. While many functions may be safely reasoned about, there are still some functions which will be inherently unsafe due to their potential effects on object lifetimes.</li>
</ul>
<p>One of the ways that godot-rust avoids large <code>unsafe</code> blocks is by using the <a href="http://cliffle.com/blog/rust-typestate/">TypeState pattern</a> with <em>temporary references</em> such as <code>TRef</code> and <code>TInstance</code>. For more information see <a href="faq/../../src/gdnative-overview/wrappers.html"><code>Ref</code>, <code>TRef</code> and <code>Instance</code></a>.</p>
<p>Here is an example of some common <code>unsafe</code> usage that you will often see and use in your own games.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_a_node(&amp;self, owner: TRef&lt;Node&gt;) {
    // This is safe because it returns an option that Rust knows how to check.
    let child = owner.get_child(&quot;foo&quot;);
    // This is safe because Rust panics if the returned `Option` is None.
    let child = child.expect(&quot;I know this should exist&quot;);
    // This is also safe because Rust panics if the returned `Option` is None.
    let child = child.cast_instance::&lt;Foo&gt;().expect(&quot;I know that it must be this type&quot;);
    // This is unsafe because the compiler cannot reason about the lifetime of `child`.
    // It is the programmer's responsibility to ensure that `child` is not freed before
    // it gets used.
    let child: Instance&lt;Foo&gt; = unsafe { child.assume_safe() };
    // This is safe because we have already asserted above that we are assuming that
    // there should be no problem and Rust can statically analyze the safety of the
    // functions.
    child.map_mut(|c, o| {
        c.bar(o);
    }).expect(&quot;this should not fail&quot;);
    // This is unsafe because it relies on Godot for function dispatch and it is
    // possible for it to call `Object.free()` or `Reference.unreference()` as
    // well as other native code that may cause undefined behavior.
    unsafe {
        child.call(&quot;bar&quot;, &amp;[])
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>By the way, safety rules are subject to an <a href="https://github.com/godot-rust/godot-rust/issues/808">ongoing discussion</a> and likely to be relaxed in future godot-rust versions.</p>
<h2 id="can-the-new-constructor-have-additional-parameters"><a class="header" href="#can-the-new-constructor-have-additional-parameters">Can the <code>new</code> constructor have additional parameters?</a></h2>
<p>Unfortunately this is currently not possible, due to a general limitation of GDNative (see <a href="https://github.com/godotengine/godot/issues/23260">related issue</a>).</p>
<p>As a result, a common pattern to work around this limitation is to use explicit initialization methods. For instance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EnemyData {
    name: String,
    health: f32,
}

#[derive(NativeClass)]
#[inherit(Object)]
struct Enemy {
    data: Option&lt;EnemyData&gt;,
}

#[methods]
impl Enemy {
    fn new(_owner: &amp;Object) -&gt; Self {
        Enemy {
            data: None,
        }
    }

    #[export]
    fn set_data(&amp;mut self, _owner: &amp;Object, name: String, health: f32) {
        self.data = Some(EnemyData { name, health });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This however has two disadvantages:</p>
<ol>
<li>You need to use an <code>Option</code> with the sole purpose of late initialization, and subsequent <code>unwrap()</code> calls or checks -- weaker invariants in short.</li>
<li>An additional type <code>EnemyData</code> for each native class like <code>Enemy</code> is required (unless you have very few properties, or decide to add <code>Option</code> for each of them, which has its own disadvantages).</li>
</ol>
<p>An alternative is to register a separate factory class, which returns fully-constructed instances:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[no_constructor] // disallow default constructor
#[inherit(Object)]
struct Enemy {
    name: String,
    health: f32,
}

#[methods]
impl Enemy {
    // nothing here
}

#[derive(NativeClass)]
#[inherit(Reference)]
struct EntityFactory {}

#[methods]
impl EntityFactory {
    #[export]
    fn enemy(&amp;self, _owner: &amp;Reference, name: String, health: f32)
    -&gt; Instance&lt;Enemy, Unique&gt; {
        Enemy { name, health }.emplace()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>So instead of <code>Enemy.new()</code> you can write <code>EntityFactory.enemy(args)</code> in GDScript.
This still needs an extra type <code>EntityFactory</code>, however you could reuse that for multiple classes.</p>
<h2 id="can-i-implement-static-methods-in-gdnative"><a class="header" href="#can-i-implement-static-methods-in-gdnative">Can I implement static methods in GDNative?</a></h2>
<p>In GDScript, classes can have static methods. However, GDNative currently doesn't allow to register static methods from bindings.</p>
<p>As a work-around, it is possible to use a ZST (zero-sized type):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Copy, Clone, Default)]
#[user_data(Aether&lt;StaticUtil&gt;)]
#[inherit(Object)]
pub struct StaticUtil;

#[methods]
impl StaticUtil {
    #[export]
    fn compute_something(&amp;self, _owner: &amp;Object, input: i32) -&gt; i32 {
        godot_print!(&quot;pseudo-static computation&quot;);
        2 * input
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/gdnative/latest/gdnative/export/user_data/struct.Aether.html"><code>Aether</code></a> is a special user-data wrapper intended for zero-sized types, that does not perform any allocation or synchronization at runtime.</p>
<p>The type needs to be instantiated somewhere on GDScript level.
Good places for instantiation are for instance:</p>
<ul>
<li>a member of a long-living util object,</li>
<li>a <a href="https://docs.godotengine.org/en/stable/getting_started/step_by_step/singletons_autoload.html">singleton auto-load object</a>.</li>
</ul>
<h2 id="how-do-i-convert-from-a-variant-to-the-underlying-rust-type"><a class="header" href="#how-do-i-convert-from-a-variant-to-the-underlying-rust-type">How do I convert from a <code>Variant</code> to the underlying Rust type?</a></h2>
<p>Assuming that a method takes an argument <code>my_node</code> as a <code>Variant</code></p>
<p>You can convert <code>my_node</code> to a <code>Ref</code>, and then to an <code>Instance</code> or <code>TInstance</code>, and mapping over it to access the Rust data type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// My class that has data
#[derive(NativeClass)]
#[inherit(Node2D)] // something specific, so it's clear when this type re-occurs in code
struct MyNode2D { ... }

/// Utility script that uses MyNode2D
#[derive(NativeClass, Copy, Clone, Default)]
#[user_data(Aether&lt;AnotherNativeScript&gt;)] // ZST, see above
#[inherit(Reference)]
pub struct AnotherNativeScript;

#[methods]
impl AnotherNativeScript {
    #[export]
    pub fn method_accepting_my_node(&amp;self, _owner: &amp;Reference, my_node: Variant) {
        // 1. Cast Variant to Ref of associated Godot type, and convert to TRef.
        let my_node = unsafe {
            my_node
                .try_to_object::&lt;Node2D&gt;()
                .expect(&quot;Failed to convert my_node variant to object&quot;)
                .assume_safe()
        };

        // 2. Obtain a TInstance which gives access to the Rust object's data.
        let my_node = my_node
            .cast_instance::&lt;MyNode2D&gt;()
            .expect(&quot;Failed to cast my_node object to instance&quot;);

        // 3. Map over the RefInstance to process the underlying user data.
        my_node
            .map(|my_node, _owner| {
                // Now my_node is of type MyNode2D.
            })
            .expect(&quot;Failed to map over my_node instance&quot;);
    }

}

<span class="boring">}
</span></code></pre></pre>
<h2 id="is-it-possible-to-set-subproperties-of-a-godot-type-such-as-a-material"><a class="header" href="#is-it-possible-to-set-subproperties-of-a-godot-type-such-as-a-material">Is it possible to set subproperties of a Godot type, such as a <code>Material</code>?</a></h2>
<p>Yes, it is possible, but it will depend on the type.</p>
<p>For example, when you need to set an <code>albedo_texture</code> on the <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.SpatialMaterial.html"><code>SpatialMaterial</code></a>, it will be necessary to use the generic <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.SpatialMaterial.html#method.set_texture"><code>set_texture()</code></a> function with the parameter <code>index</code>.</p>
<p>While a similar case applies for <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ShaderMaterial.html"><code>ShaderMaterial</code></a> in the case of shader material, to set the shader parameters, you will need to use the <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ShaderMaterial.html#method.set_shader_param"><code>set_param()</code></a> method with the relevant parameter name and value.</p>
<p>Direct access to such properties is planned in <a href="https://github.com/godot-rust/godot-rust/issues/689">godot-rust/godot-rust#689</a>.</p>
<h2 id="what-is-the-rust-equivalent-of-preload"><a class="header" href="#what-is-the-rust-equivalent-of-preload">What is the Rust equivalent of <code>preload</code>?</a></h2>
<p>Unfortunately, there is no equivalent to preload in languages other than GDScript, because preload is GDScript-specific magic that works at compile time. If you read the official documentation on preload, it says:</p>
<blockquote>
<p>&quot;Returns a resource from the filesystem that is <em>loaded during script parsing.</em>&quot; <strong>(emphasis mine)</strong></p>
</blockquote>
<p>This is only possible in GDScript because the parser is deeply integrated into the engine.</p>
<p>You can use <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ResourcePreloader.html"><code>ResourcePreloader</code></a> as a separate node in your scene, which will work regardless of whether you use Rust or GDScript. However, note that if you create a <code>ResourcePreloader</code> in your code, you will still be loading these resources at the time of execution, because there is no way for the engine to know what resources are being added before actually running the code.</p>
<p>The <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ResourceLoader.html"><code>ResourceLoader</code></a> should be used in most cases.</p>
<p>Also, you can go with a <code>static Mutex&lt;HashMap&lt;..&gt;&gt;</code> variable and load everything you need there during a loading screen.</p>
<h2 id="how-can-function-parameters-accept-godot-subclasses-polymorphism"><a class="header" href="#how-can-function-parameters-accept-godot-subclasses-polymorphism">How can function parameters accept Godot subclasses (polymorphism)?</a></h2>
<p><em>Static</em> (compile-time) polymorphism can be achieved by a combination of the <code>SubClass</code> trait and <code>upcast()</code>.</p>
<p>For example, let's assume we want to implement a helper function that should accept any kind of <a href="https://docs.godotengine.org/en/stable/classes/class_control.html#class-control"><code>Container</code></a>. The helper function can make use of <code>SubClass</code> and <code>upcast()</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_container&lt;T&gt;(container: TRef&lt;'_, T&gt;)
    where T: GodotObject + SubClass&lt;Container&gt;
// this means: accept any TRef&lt;T&gt; where T inherits `Container`
{
    // First upcast to a true container:
    let container = container.upcast::&lt;Container&gt;();
    // Now you can call `Container` specific methods like:
    container.set_size(...);
}
<span class="boring">}
</span></code></pre></pre>
<p>This function can now be used with arbitrary subclasses, for instance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_usage() {
    let panel: Ref&lt;PanelContainer&gt; = PanelContainer::new().into_shared();
    let panel: TRef&lt;PanelContainer&gt; = unsafe { panel.assume_safe() };
    do_something_with_container(panel);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that <code>SubClass</code> is only a marker trait that models the inheritance relationship of Godot classes, and doesn't perform any conversion by itself. For instance, <code>x: Ref&lt;T&gt;</code> or <code>x: TRef&lt;'_, T&gt;</code> satisfying <code>T: GodotObject + SubClass&lt;Container&gt;</code> doesn't mean that <code>x</code> can be used as a <code>Container</code> directly. Rather, it ensures that e.g. <code>x.upcast::&lt;Container&gt;()</code> is guaranteed to work, because <code>T</code> is a subclass of <code>Container</code>. Therefore, it is a common pattern to use <code>SubClass</code> constraints in combination with <code>.upcast()</code> to convert to the base class, and actually use <code>x</code> as such.</p>
<p>Of course, you could also delegate the work to upcast to the call site:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_container(container: TRef&lt;Container&gt;) { ... }

fn some_usage() {
    let panel: TRef&lt;PanelContainer&gt; = ...;
    do_something_with_container(panel.upcast());
}
<span class="boring">}
</span></code></pre></pre>
<p>This would also support <em>dynamic</em> (runtime) polymorphism -- <code>Ref&lt;T&gt;</code> can also store subclasses of <code>T</code>.</p>
<h2 id="what-is-the-rust-equivalent-of-onready-var"><a class="header" href="#what-is-the-rust-equivalent-of-onready-var">What is the Rust equivalent of <code>onready var</code>?</a></h2>
<p>Rust does not have a direct equivalent to <code>onready var</code>. The most idiomatic workaround with Rust is to use <code>Option&lt;Ref&lt;T&gt;&gt;</code> of you need the Godot node type or <code>Option&lt;Instance&lt;T&gt;&gt;</code> if you are using a Rust based <code>NativeClass</code>.</p>
<pre><code class="language-gdscript">extends Node
class_name MyClass
onready var node = $Node2d
</code></pre>
<p>You would need to use the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Default)]
#[inherit(Node)]
#[no_constructor]
struct MyNode {
    // late-initialization is modeled with Option
    // the Default derive will initialize both to None
    node2d: Option&lt;Ref&lt;Node&gt;&gt;,
    instance: Option&lt;Ref&lt;MyClass&gt;&gt;,
}

#[methods]
impl MyNode {
    #[export]
    fn _ready(&amp;self, owner: TRef&lt;Node&gt;) {
        // Get an existing child node that is a Godot class.
        let node2d = owner
            .get_node(&quot;Node2D&quot;)
            .expect(&quot;this node must have a child with the path `Node2D`&quot;);
        let node2d = unsafe { node2d.assume_safe() };
        let node2d = node2d.cast::&lt;Node2D&gt;();
        self.node2d = Some(node2d.claim());

        // Get an existing child node that is a Rust class.
        let instance = owner
            .get_node(&quot;MyClass&quot;)
            .expect(&quot;this node must have a child with the path `MyClass`&quot;);
        let instance = unsafe { instance.assume_safe() };
        let instance = instance.cast_instance::&lt;MyClass&gt;()
                        .expect(&quot;child must be type `MyClass`&quot;);
        self.instance = Some(instance.claim());
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="what-types-are-supported-for-passing-through-the-gdnative-api"><a class="header" href="#what-types-are-supported-for-passing-through-the-gdnative-api">What types are supported for passing through the GDNative API?</a></h2>
<p>The GDNative API supports any type that implements the <a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.ToVariant.html"><code>ToVariant</code></a> and/or <a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.FromVariant.html"><code>FromVariant</code></a> traits.</p>
<p>To use a type as a property, in addition to the above, the type will also need to implement the <a href="https://docs.rs/gdnative/latest/gdnative/nativescript/trait.Export.html"><code>Export</code></a> trait.</p>
<p>Some concrete examples of types that can be used with the GDNative API are the following:</p>
<ul>
<li><a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.Variant.html"><code>Variant</code></a>, this is Godot's &quot;any&quot; type. It must be converted before it can be used.</li>
<li>A subset of scalar types such as <code>i64</code>, <code>f64</code>, <code>bool</code>, etc.</li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> and <a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.GodotString.html"><code>GodotString</code></a>.</li>
<li><a href="https://docs.rs/gdnative/latest/gdnative/core_types/index.html">Godot core types</a> such as <a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.Color.html"><code>Color</code></a>, <a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.Aabb.html"><code>Aabb</code></a>, <a href="https://docs.rs/gdnative/latest/gdnative/core_types/type.Transform2D.html"><code>Transform2D</code></a>, <a href="https://docs.rs/gdnative/latest/gdnative/core_types/type.Vector2.html"><code>Vector2</code></a>, etc.</li>
<li>Godot classes such as <code>Node</code>, <code>Reference</code>, etc. which must be accessed via <a href="https://docs.rs/gdnative/latest/gdnative/struct.Ref.html"><code>Ref&lt;T&gt;</code></a> (you can't pass them by value, because Godot owns them).</li>
<li>Any Rust struct that derives <a href="https://docs.rs/gdnative/latest/gdnative/derive.NativeClass.html"><code>NativeClass</code></a>, through <a href="https://docs.rs/gdnative/latest/gdnative/nativescript/struct.Instance.html"><code>Instance&lt;T&gt;</code></a>.</li>
</ul>
<h2 id="how-can-i-profile-my-code-to-measure-performance"><a class="header" href="#how-can-i-profile-my-code-to-measure-performance">How can I profile my code to measure performance?</a></h2>
<p>There are a lot of ways to profile your code and they vary in complexity.</p>
<p>The simplest way is to use the <code>#[gdnative::profiled]</code> procedural macro that enables Godot to profile the attributed function. This option is useful for comparing performance gains when porting GDScript code to Rust or as a way to understand the relative &quot;frame time&quot; of your code. Don't forget to compile Rust code with <code>--release</code>!</p>
<p>For more information about the Godot profiler, please refer to the <a href="https://docs.godotengine.org/en/stable/tutorials/debug/debugger_panel.html?highlight=profiler#profiler">official documentation</a>.</p>
<p>In order for Godot to profile your function, all the following must be true:</p>
<ul>
<li>The function belongs to a struct that derives <code>NativeClass</code>.</li>
<li>The function is included in an <code>impl</code> block that is attributed with the <code>#[methods]</code> attribute.</li>
<li>The function is attributed with <code>#[export]</code> attribute.</li>
</ul>
<p>As such, this method is <em>only</em> useful for exported code and is subject to the Godot profiler's limitations, such as millisecond accuracy in profiler metrics.</p>
<p>The following example illustrates how your code should look when being profiled:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
struct MyClass {}

#[methods]
impl MyClass {
    fn new(_owner: &amp;Node) -&gt; Self {
        Self {}
    }

    #[export]
    #[gdnative::profiled]
    fn my_profiled_function(&amp;self, _owner: &amp;Node) {
        // Any code in this function will be profiled.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you require insight into Rust code that is not exported to Godot, or would like more in-depth information regarding execution of your program, it will be necessary to use a Rust compatible profiler such as <a href="https://crates.io/crates/puffin">puffin</a> or <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a>. These tools can be used to more accurately determine bottlenecks and the general performance of your Rust code.</p>
<p><strong>Note:</strong> There are many more profilers than the ones listed and you should do your own research before selecting which one you wish to use.</p>
<p>For more information about profiling and other rust performance tips, please check out the <a href="https://nnethercote.github.io/perf-book/profiling.html">Rust performance book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-multithreading"><a class="header" href="#faq-multithreading">FAQ: Multithreading</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="faq/multithreading.html#how-do-i-use-multithreading">How do I use multithreading?</a></li>
<li><a href="faq/multithreading.html#why-does-my-game-freeze-while-using-multiple-threads">Why does my game freeze while using multiple threads?</a></li>
<li><a href="faq/multithreading.html#why-is-accessing-the-servers-using-multiple-threads-slow">Why is accessing the servers using multiple threads slow?</a></li>
<li><a href="faq/multithreading.html#why-do-i-get-the-differentthread-error">Why do I get the <code>DifferentThread</code> error?</a></li>
</ul>
<h2 id="how-do-i-use-multithreading"><a class="header" href="#how-do-i-use-multithreading">How do I use multithreading?</a></h2>
<p>Make sure you read <a href="https://docs.godotengine.org/en/stable/tutorials/performance/threads/thread_safe_apis.html">Godot's thread safety guidelines</a>.</p>
<blockquote>
<p>This is <strong>EXTREMELY IMPORTANT</strong>.</p>
</blockquote>
<p>Read the guidelines again. Make sure you fully understand them.<br />
Anything not explicitly allowed there is a potential minefield.</p>
<p>This cannot be stressed enough, because threading can easily turn a fun gamedev experience into a debugging nightmare. In fact, most occurrences
of undefined behavior (UB) with godot-rust occur not because of FFI, dangling objects or broken C++ code, but because threads are used incorrectly.
By understanding the implications of multithreading, you can save a lot of effort.</p>
<p>A few points are worth highlighting in particular:</p>
<ol>
<li>Do not mix GDScript's <code>Thread/Mutex</code> classes with Rust's <a href="https://doc.rust-lang.org/std/thread"><code>std::thread</code></a> and
<a href="https://doc.rust-lang.org/stable/std/sync"><code>std::sync</code></a> modules; they are not compatible.
If you absolutely must access GDScript threads from Rust, use the correct <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.Thread.html"><code>Thread</code></a>
and <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.Mutex.html"><code>Mutex</code></a> APIs for it.</li>
<li>Prefer Rust threads whenever possible. Safe Rust statically guarantees that no race conditions can occur (deadlocks are still possible).
In practice, this often means that:
<ul>
<li>your game logic (e.g. loading a map) can run in a separate thread, entirely without touching any Godot APIs</li>
<li>your main thread is exclusively accessing Godot APIs</li>
<li>the two threads can communicate via <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">channels</a>.</li>
</ul>
</li>
<li>As elaborated in Godot's guidelines, most Godot classes are <strong>simply not thread-safe</strong>. This means you can absolutely not access them
concurrently without synchronization. Even if things seem to work, you may invoke UB which can manifest in hard-to-find places.</li>
<li>It is tempting to think that synchronizing concurrent access to an object through <code>Mutex</code> solves threading issues. However, this may not be
the case: sometimes there are hidden dependencies between <em>unrelated</em> types -- for example, a <code>Resource</code> might access a global
registry, which is currently written by a <em>different</em> object in another thread. Some types internally use shared caches. A lot of these things
are undocumented, which means you must know Godot's implementation to be sure. And the implementation can always change and introduce a bug in
the future. </li>
</ol>
<p><strong>TLDR:</strong> Be conservative regarding assumptions about the thread-safety of Godot APIs.<br />
Rust threads (without Godot APIs) are a very powerful tool -- use them!</p>
<h2 id="why-does-my-game-freeze-while-using-multiple-threads"><a class="header" href="#why-does-my-game-freeze-while-using-multiple-threads">Why does my game freeze while using multiple threads?</a></h2>
<p>Make sure you have multi-threading enabled under <em>Project Settings &gt; Rendering &gt; Threading</em>.</p>
<p>In addition, you will need to ensure that you are not ending up with a deadlock scenario within your Rust code.</p>
<p>Last, you may have violated one of the multithreading guidelines and tips in the first section.</p>
<h2 id="why-is-accessing-the-servers-using-multiple-threads-slow"><a class="header" href="#why-is-accessing-the-servers-using-multiple-threads-slow">Why is accessing the servers using multiple threads slow?</a></h2>
<p>Aside from deadlock issues, there are a few potential points to investigate when using Godot's servers.</p>
<h3 id="potential-cause-1---command-queue-is-too-small"><a class="header" href="#potential-cause-1---command-queue-is-too-small">Potential cause #1 - command queue is too small</a></h3>
<p>For multi-threaded access the servers use a thread-safe command queue. This allows you to send multiple commands from any thread. These queues have a fixed size that can be set in the threading section of the Memory -&gt; Limits section of the Project settings.</p>
<h3 id="potential-cause-2---rayon-parallel-iterators"><a class="header" href="#potential-cause-2---rayon-parallel-iterators">Potential cause #2 - rayon parallel iterators</a></h3>
<p>The reference created by a server method such as  <code>VisualServer::godot_singleton()</code> is not thread-safe. As such, you have to individually get a reference to the singleton.
This can cause severe slowdown, that would not occur if the same job were run from a single thread.</p>
<p>Multi-threading with servers requires that you manually create a thread pool that can hold the reference to the server. 
Additional testing is required to ensure that this is an actual optimization.</p>
<h2 id="why-do-i-get-the-differentthread-error"><a class="header" href="#why-do-i-get-the-differentthread-error">Why do I get the <code>DifferentThread</code> error?</a></h2>
<p>For example, what does the following error indicate?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ERROR: &lt;native&gt;: gdnative-core: method call failed with error: 
       DifferentThread { original: ThreadId(1), current: ThreadId(2) }
   At: src/path/to/class.rs:29
ERROR: &lt;native&gt;: gdnative-core: check module level documentation
                 on gdnative::user_data for more information
   At: src/path/to/class.rs:29
<span class="boring">}
</span></code></pre></pre>
<p>If you call certain code from Godot and receive the above error, it is likely that you need to change the <code>user_data</code> that comes with 
your <code>NativeClass</code> derive. If no type is specified, it defaults to <code>LocalCellData</code>, which can only be used from the thread it was created in.</p>
<p>See the <a href="https://docs.rs/gdnative/latest/gdnative/export/user_data">official docs</a> for more information on when you should use each type of data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-configuration"><a class="header" href="#faq-configuration">FAQ: Configuration</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h2>
<ul>
<li><a href="faq/configuration.html#how-do-i-create-the-library-file-for-my-gdnative-binary">How do I create the library file for my GDNative binary?</a></li>
<li><a href="faq/configuration.html#once-i-create-the-gdnlib-file-how-do-i-create-the-native-script-so-that-i-can-attach-it-to-the-nodes-in-the-scene-tree">Once I create the <code>.gdnlib</code> file, how do I create the native script, so that I can attach it to the nodes in the scene tree?</a></li>
<li><a href="faq/configuration.html#c-headers-not-found-by-bindgen">C headers not found by bindgen</a></li>
<li><a href="faq/configuration.html#why-arent-my-scripts-showing-up-in-the-add-node-portion-of-the-editor-even-though-they-inherit-from--node-node2d-spatial-or-control">Why aren't my scripts showing up in the Add Node portion of the editor, even though they inherit from  <code>Node</code>, <code>Node2D</code>, <code>Spatial</code> or <code>Control</code>?</a></li>
<li><a href="faq/configuration.html#can-i-use-rust-for-a-tool-script">Can I use Rust for a tool script?</a></li>
<li><a href="faq/configuration.html#is-it-possible-to-use-multiple-libraries-with-gdnative">Is it possible to use multiple libraries with GDNative?</a></li>
<li><a href="faq/configuration.html#can-i-expose-insert-rust-crate-name-for-use-with-godot-and-gdscript">Can I expose {insert Rust crate name} for use with Godot and GDScript?</a></li>
<li><a href="faq/configuration.html#how-do-i-get-auto-completion-with-rust-analyzer">How do I get auto-completion with rust-analyzer?</a></li>
<li><a href="faq/configuration.html#how-do-i-get-auto-completion-with-intellij-rust-plugin">How do I get auto-completion with IntelliJ-Rust plugin?</a></li>
<li><a href="faq/configuration.html#how-can-i-make-my-debug-builds-more-performant">How can I make my debug builds more performant?</a></li>
</ul>
<h2 id="how-do-i-create-the-library-file-for-my-gdnative-binary"><a class="header" href="#how-do-i-create-the-library-file-for-my-gdnative-binary">How do I create the library file for my GDNative binary?</a></h2>
<p>You can create .gdnlib files with either of the following methods.</p>
<h3 id="editor"><a class="header" href="#editor">Editor</a></h3>
<ol>
<li>In the editor, right click in the File System and Select <em>New Resource</em>. </li>
<li>Select <em>GDNativeLibrary</em> from the menu.</li>
<li>Save as new GDNativeLibrary. The typical file extension is <code>.gdnlib</code>.</li>
<li>Select the GDNativeLibrary.</li>
<li>For each desired target, select a path to the location of the library created by Cargo.</li>
</ol>
<h3 id="manual"><a class="header" href="#manual">Manual</a></h3>
<p>Create a text file with the <code>.gdnlib</code> extension with the following content.
Please note: you only need to include paths for the targets you plan on building for.</p>
<pre><code class="language-toml">[entry]
X11.64=&quot;res://path/to/lib{binary-name}.so&quot;
OSX.64=&quot;res://path/to/lib{binary-name}.dylib&quot;
Windows.64=&quot;res://path/to/{binary-name}.dll&quot;

[dependencies]
X11.64=[  ]
OSX.64=[  ]
Windows.64 = [ ]

[general]
singleton=false
load_once=true
symbol_prefix=&quot;godot_&quot;
reloadable=true
</code></pre>
<h2 id="once-i-create-the-gdnlib-file-how-do-i-create-the-native-script-so-that-i-can-attach-it-to-the-nodes-in-the-scene-tree"><a class="header" href="#once-i-create-the-gdnlib-file-how-do-i-create-the-native-script-so-that-i-can-attach-it-to-the-nodes-in-the-scene-tree">Once I create the <code>.gdnlib</code> file, how do I create the native script, so that I can attach it to the nodes in the scene tree?</a></h2>
<p>Script files can be created in two ways.</p>
<ol>
<li>From the editor.</li>
<li>Manually by creating a <code>.gdns</code> file with the following code snippet.</li>
</ol>
<pre><code class="language-toml">[gd_resource type=&quot;NativeScript&quot; load_steps=2 format=2]

[ext_resource path=&quot;res://path/to/{filename}.gdnlib&quot; type=&quot;GDNativeLibrary&quot; id=1]

[resource]
resource_name = &quot;{class-name}&quot;
class_name = &quot;{class-name}&quot;
library = ExtResource( 1 )
</code></pre>
<h2 id="c-headers-not-found-by-bindgen"><a class="header" href="#c-headers-not-found-by-bindgen">C headers not found by bindgen</a></h2>
<p>When building the library, <code>bindgen</code> may produce errors that look like this:</p>
<pre><code>godot-rust/gdnative-sys/godot_headers/gdnative/string.h:39:10: fatal error: 'wchar.h' file not found
</code></pre>
<p>This means that <code>bindgen</code> was unable to find the C system headers for your platform. If you can locate the headers manually, you may try setting the <code>C_INCLUDE_PATH</code> environment variable so <code>libclang</code> could find them. If on Windows, you may try building from the Visual Studio &quot;developer console&quot;, which should setup the appropriate variables for you.</p>
<h2 id="why-arent-my-scripts-showing-up-in-the-add-node-portion-of-the-editor-even-though-they-inherit-from--node-node2d-spatial-or-control"><a class="header" href="#why-arent-my-scripts-showing-up-in-the-add-node-portion-of-the-editor-even-though-they-inherit-from--node-node2d-spatial-or-control">Why aren't my scripts showing up in the <em>Add Node</em> portion of the editor, even though they inherit from  <code>Node</code>, <code>Node2D</code>, <code>Spatial</code> or <code>Control</code>?</a></h2>
<p>Due to limitations with Godot 3.x's version of GDNative, NativeScript types do not get registered in the class database. As such, these classes are not included in the <em>Create New Node</em> dialog.</p>
<p>A workaround to this issue has been included in the recipe <a href="faq/../recipes/custom-node-plugin.html">Custom Nodes Plugin</a>.</p>
<h2 id="can-i-use-rust-for-a-tool-script"><a class="header" href="#can-i-use-rust-for-a-tool-script">Can I use Rust for a <a href="https://docs.godotengine.org/en/stable/tutorials/misc/running_code_in_the_editor.html">tool script</a>?</a></h2>
<p>Yes, any Rust struct that inherits from <code>NativeClass</code> can be also used as a tool class by using the <code>InitHandle::add_tool_class</code> during native script initialization instead of <code>InitHandle::add_class</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
stuct MyTool {}
#[methods]
impl MyTool {
    fn new (_owner: &amp;Node) -&gt; Self {
        Self {}
    }
}

fn init(handle: InitHandle) {
    handle.add_tool_class::&lt;InitHandle&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p>Please also see the <a href="https://github.com/godot-rust/godot-rust/tree/master/examples/native-plugin">native-plugin</a> that is the Rust version of the <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/editor/index.html">editor plugin</a> tutorial.</p>
<p><strong>Important</strong></p>
<ul>
<li>Editor plugins do not support the hot reload feature. If making use of tool classes, your <code>GDNativeLibrary</code> must have <code>reloadable=false</code> or the plugins will crash when the editor loses focus.</li>
<li>It is advised that <code>GDNativeLibrary</code> files for editor plugins be compiled as a separate &quot;cdylib&quot; from the <code>GDNativeLibrary</code> that may need to be recompiled during development, such as game logic.</li>
</ul>
<h2 id="is-it-possible-to-use-multiple-libraries-with-gdnative"><a class="header" href="#is-it-possible-to-use-multiple-libraries-with-gdnative">Is it possible to use multiple libraries with GDNative?</a></h2>
<p>Yes. This is possible, but it should be avoided unless necessary. Generally you should create one <code>GDNativeLibrary</code> (<code>.gdnlib</code>) and associate many <code>NativeScript</code> (<code>.gdns</code>) files with the single library.</p>
<p>The most common use-case for using multiple <code>GDNativeLibrary</code> files is when creating editor plugins in Rust that are either intended for distribution or cannot be hot reloaded.</p>
<p>If you do have a scenario that requires multiple <code>GDNativeLibrary</code>, you can create as many libraries as you need for your project. Be mindful that it is possible for name collision to occur when loading from multiple dynamic libraries. This can occur in the event that multiple libraries attempt to register the same class in their init function.</p>
<p>To avoid these collisions, rather than the <code>godot_init!</code> initialization macro, prefer the use of the individual macros.</p>
<p>For example, if we want to define the symbol_prefix for our library &quot;my_symbol_prefix&quot;, we can use the macros below.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// _ indicates that we do not have any specific callbacks needed from the engine for initialization. So it will automatically create
// We add the prefix onto the `gdnative_init` which is the name of the callback that Godot will use when attempting to run the library
godot_gdnative_init!(_ as my_symbol_prefix_gdnative_init);
// native script init requires that the registration function be defined. This is commonly named `fn init(init: InitHandle)` in most of the examples
// We add the prefix onto the `native_script_init` which is the name of the callback that Godot will use when attempting to intialize the script classes
godot_nativescript_init!(registration_function as my_symbol_prefix_nativescript_init);
// _ indicates that we do not have any specific callbacks needed from the engine for initialization. So it will automatically create
// We add the prefix onto the `gdnative_terminate` which is the name of the callback that Godot will use when shutting down the library
godot_gdnative_terminate!(_ as my_symbol_prefix_gdnative_terminate);
<span class="boring">}
</span></code></pre></pre>
<h2 id="can-i-expose-insert-rust-crate-name-for-use-with-godot-and-gdscript"><a class="header" href="#can-i-expose-insert-rust-crate-name-for-use-with-godot-and-gdscript">Can I expose {insert Rust crate name} for use with Godot and GDScript?</a></h2>
<p>Yes, with NativeScript so long as you can create a <code>NativeScript</code> wrapper you can create GDScript bindings for a Rust crate. See the <a href="faq/../recipes/logging.html">logging recipe</a> for an example of wrapping a Rust logging crate for use with GDScript.</p>
<h2 id="how-do-i-get-auto-completion-with-rust-analyzer"><a class="header" href="#how-do-i-get-auto-completion-with-rust-analyzer">How do I get auto-completion with rust-analyzer?</a></h2>
<p><code>godot-rust</code> generates most of the gdnative type's code at compile-time. Editors using <a href="https://github.com/rust-analyzer/rust-analyzer">rust-analyzer</a> struggle to autocomplete those types:</p>
<p><img src="faq/img/no-completion.png" alt="no-completion" /></p>
<p>People <a href="https://github.com/rust-analyzer/rust-analyzer/issues/5040">reported</a> similar issues and found that switching on the <code>&quot;rust-analyzer.cargo.loadOutDirsFromCheck&quot;: true</code> setting fixed it:</p>
<p><img src="faq/img/completion.png" alt="completion" /></p>
<h2 id="how-do-i-get-auto-completion-with-intellij-rust-plugin"><a class="header" href="#how-do-i-get-auto-completion-with-intellij-rust-plugin">How do I get auto-completion with IntelliJ-Rust plugin?</a></h2>
<p>Similar to rust-analyzer, IntelliJ-Family IDEs struggle to autocomplete gdnative types generated at compile-time.</p>
<p>There are two problems preventing autocompletion of gdnative types in IntelliJ-Rust.</p>
<p>First, the features necessary are (as of writing) considered experimental and must be enabled. Press <code>shift</code> twice to open the find all dialog and type <code>Experimental features...</code> and click the checkbox for <code>org.rust.cargo.evaluate.build.scripts</code>.  Note that <code>org.rust.cargo.fetch.out.dir</code> will also work, but is known to be less performant and may be phased out.</p>
<p>Second, the bindings files generated (~8mb) are above the 2mb limit for files to be processed. As <a href="https://github.com/intellij-rust/intellij-rust/issues/6571#">reported</a> you can increase the limit with the steps below.</p>
<ul>
<li>open custom VM options dialog (<code>Help</code> | <code>Find Action</code> and type <code>Edit Custom VM Options</code>)</li>
<li>add <code>-Didea.max.intellisense.filesize=limitValue</code> line where <code>limitValue</code> is desired limit in KB, for example, 10240. Note, it cannot be more than 20 MB.</li>
<li>restart IDE</li>
</ul>
<h2 id="how-can-i-make-my-debug-builds-more-performant"><a class="header" href="#how-can-i-make-my-debug-builds-more-performant">How can I make my debug builds more performant?</a></h2>
<p><strong>Note</strong>: These changes may slow down certain aspects of the build times for your game.</p>
<p>Some simple ways to make your debug builds faster is to update the following profiles in your workspace cargo file.</p>
<pre><code class="language-toml">[profile.dev.package.&quot;*&quot;]
opt-level = 3

[profile.dev]
opt-level=1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-versioning-and-supported-platforms"><a class="header" href="#faq-versioning-and-supported-platforms">FAQ: Versioning and supported platforms</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of contents</a></h2>
<ul>
<li><a href="faq/support.html#what-does-godot-rusts-version-mean">What does godot-rust's version mean?</a></li>
<li><a href="faq/support.html#is-godot-rust-stable">Is godot-rust stable?</a></li>
<li><a href="faq/support.html#will-godot-rust-support-godot-40">Will godot-rust support Godot 4.0?</a></li>
<li><a href="faq/support.html#what-is-the-scope-of-the-godot-rust-project">What is the scope of the godot-rust project?</a></li>
<li><a href="faq/support.html#will-godot-rust-speed-up-my-game-in-godot">Will godot-rust speed up my game in Godot?</a></li>
<li><a href="faq/support.html#which-platforms-are-supported">Which platforms are supported?</a></li>
<li><a href="faq/support.html#does-godot-rust-support-consoles">Does godot-rust support consoles?</a></li>
</ul>
<h2 id="what-does-godot-rusts-version-mean"><a class="header" href="#what-does-godot-rusts-version-mean">What does godot-rust's version mean?</a></h2>
<p>godot-rust follows <a href="https://doc.rust-lang.org/cargo/reference/semver.html">Cargo's semantic versioning</a> for the API breaking changes.</p>
<h2 id="is-godot-rust-stable"><a class="header" href="#is-godot-rust-stable">Is godot-rust stable?</a></h2>
<p>godot-rust will not be considered stable until MAJOR version 1.x.x. As such, MINOR version upgrades are subject to potential API breaking changes, but PATCH versions will not break the API.</p>
<h2 id="will-godot-rust-support-godot-40"><a class="header" href="#will-godot-rust-support-godot-40">Will godot-rust support Godot 4.0?</a></h2>
<p>This is still being discussed for how to approach Godot 4.0 support. Currently the team has finished merging the new <a href="https://godotengine.org/article/introducing-gd-extensions">GDExtension API</a> and introduced the progress in the Cpp extensions.</p>
<p>More information about the Godot 4.0 can be found in the <a href="faq/../faq/godot4.html">dedicated FAQ Page</a>.</p>
<h2 id="what-is-the-scope-of-the-godot-rust-project"><a class="header" href="#what-is-the-scope-of-the-godot-rust-project">What is the scope of the godot-rust project?</a></h2>
<p><strong>Similar Questions</strong></p>
<p>Why is X feature not available in the API?
Why does X function take Y parameters and return Z?</p>
<p><strong>Answer</strong></p>
<p>The short answer is &quot;that is how the Godot API works&quot;. As godot-rust is focused on the bindings to Godot, we follow the API.</p>
<p>The longer answer is that the goal of the bindings is to ease the friction between using Rust and interacting with the Godot API. This is accomplished by use of Procedural Macros as well as clever use of traits and trait conversions to keep friction and <code>unsafe</code> blocks to a minimum.</p>
<p>Types, which are not part of Godot's <code>Object</code> class hierarchy, have an implementation in Rust. This avoids FFI overhead and allows code to be more idiomatic. Examples are <code>Vector2</code>, <code>Vector3</code>, <code>Color</code>, <code>GodotString</code>, <code>Dictionary</code>, etc.</p>
<h2 id="will-godot-rust-speed-up-my-game-in-godot"><a class="header" href="#will-godot-rust-speed-up-my-game-in-godot">Will godot-rust speed up my game in Godot?</a></h2>
<p>Short Answer: It depends on what you are building and the bottlenecks, but it's pretty fast(tm).</p>
<p>Longer Answer: Generally speaking, compared to GDScript, Rust will (in most cases) be a large performance increase.</p>
<p>Compared to an C or C++ GDNative, the performance should be similar.</p>
<p>Compared to a C++ Engine module, the performance will probably be somewhat slower as GDNative modules cannot take advantage of certain optimizations and need to use the C Foreign Function Interface at runtime.</p>
<p>Caveat: The above apply only to release builds with appropriate release settings. When comparing to debug builds in Rust can be very slow.</p>
<p>Caveat 2: It is still possible to write Rust code that has poor performance. You will still need to be mindful of the specific algorithms that you are choosing.</p>
<p>Caveat 3: A lot of code in a game is not performance-critical and as such, Rust will help only in limited ways. When deciding between GDScript and Rust, you should also consider other factors such as static type safety, scalability, ecosystem and prototyping speed. Try to use the best of both worlds, it's very well possible to have part of your code in GDScript and part in Rust.</p>
<h2 id="which-platforms-are-supported"><a class="header" href="#which-platforms-are-supported">Which platforms are supported?</a></h2>
<p>Short Answer: Wherever you can get your code (and Godot) to run. :)</p>
<p>Long Answer: Rust and Godot are natively available for Windows, Linux, Android and iOS export targets.</p>
<p>As of writing, WASM targets are a tentatively doable, but it requires additional configuration and is currently not supported out of the box. The godot-rust bindings do not officially support this target. The progress in this regard can be tracked in <a href="https://github.com/godot-rust/godot-rust/issues/647">godot-rust/godot-rust#647</a>.</p>
<h2 id="does-godot-rust-support-consoles"><a class="header" href="#does-godot-rust-support-consoles">Does godot-rust support consoles?</a></h2>
<p>The official position of the godot-rust project is that, we do not have the ability to offer console support due to a lacking access to the SDK.</p>
<p>As for whether or not it is possible to compile Rust to run on a console, due to the Non-disclosure Agreements that are a part of the console SDKs, it is unlikely that anyone can give you a definitive answer.</p>
<p>The official Godot documentation <a href="https://docs.godotengine.org/en/stable/tutorials/platform/consoles.html">goes into more details</a> with how this works from a Godot perspective. Please keep in mind that this does not necessarily extend to GDNative.</p>
<p>Regarding whether Rust can run on a console or not, as most modern consoles are using x86 processor architectures, it should be possible to compile for them. The primary issue will be whether the console manufacturer has a version of the Rust standard library that is building for their console. If not, it would be necessary to port it or leverage a port from another licensed developer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-community"><a class="header" href="#faq-community">FAQ: Community</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of contents</a></h2>
<ul>
<li><a href="faq/community.html#i-need-help-where-can-i-ask">I need help, where can I ask?</a></li>
</ul>
<h2 id="i-need-help-where-can-i-ask"><a class="header" href="#i-need-help-where-can-i-ask">I need help, where can I ask?</a></h2>
<p>The godot-rust project uses several different sources for different kinds of information.</p>
<h3 id="1---the-godot-rust-documentation-is-hosted-at-docsrs"><a class="header" href="#1---the-godot-rust-documentation-is-hosted-at-docsrs">1 - The godot-rust documentation is hosted at <a href="https://docs.rs/gdnative/">docs.rs</a></a></h3>
<p>Specific places to start in the  would be the following:</p>
<ul>
<li><a href="https://docs.rs/gdnative/latest/gdnative/api/index.html">API documentation</a> this is useful to find the necessary includes from the Godot API that are not directly implemented in the preludes.
<ul>
<li><a href="https://docs.rs/gdnative/latest/gdnative/trait.GodotObject.html">Godot Object</a> includes all of the information about the trait that all Godot API objects implement. </li>
<li><a href="https://docs.rs/gdnative/latest/gdnative/derive.NativeClass.html">NativeClass</a> includes all the derive macro attributes that you can use to integrate your script class with godot.</li>
</ul>
</li>
</ul>
<h3 id="2---the-official-godot-docs"><a class="header" href="#2---the-official-godot-docs">2 - The Official Godot Docs</a></h3>
<p>As godot-rust is the layer that wraps the <a href="https://docs.godotengine.org/en/stable/classes/index.html">Godot API</a>, the effects and use cases for many of the methods are available in the Official Docs. Consulting this is a great place whenever you have questions for anything specific to Godot that is outside the bounds of godot-rust.</p>
<p><a href="https://docs.godotengine.org/en/stable/index.html">Godot docs</a></p>
<h3 id="3---the-godot-rust-discord"><a class="header" href="#3---the-godot-rust-discord">3 - The Godot Rust Discord</a></h3>
<p>For more complex questions the fastest way to get an answer is to reach out to us and fellow developers on the <a href="https://discord.gg/FNudpBD">godot-rust Discord</a>.</p>
<h3 id="4---if-it-appears-to-be-a-bug-open-a-github-issue"><a class="header" href="#4---if-it-appears-to-be-a-bug-open-a-github-issue">4 - If it appears to be a bug, open a Github issue</a></h3>
<p>If you find a bug or an issue with the godot-rust bindings or have an idea for future development, please feel free to open up a Github issue and we'd be happy to take a look.</p>
<p>Please note, due to the limited resources for maintaining this project, bugs generally take precendence over feature requests.</p>
<p>In addition, Github issues are not intended for general questions as only project maintainers and contributors generally read and track new issues. As such, we would highly recommend seeking out one of the above options before opening an issue if you have a question.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-godot-40-status"><a class="header" href="#faq-godot-40-status">FAQ: Godot 4.0 Status</a></h1>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of contents</a></h2>
<ul>
<li><a href="faq/godot4.html#what-is-the-status-of-godot-4-support">What is the status of Godot 4 Support?</a></li>
<li><a href="faq/godot4.html#what-is-gdextension-why-arent-we-just-upgrading-gdnative">What is GDExtension? Why aren't we just upgrading GDNative?</a></li>
<li><a href="faq/godot4.html#what-do-we-know-so-far">What do we know so far?</a></li>
<li><a href="faq/godot4.html#how-can-i-help">How can I help?</a></li>
</ul>
<h2 id="what-is-the-status-of-godot-4-support"><a class="header" href="#what-is-the-status-of-godot-4-support">What is the status of Godot 4 Support?</a></h2>
<p>Currently we are still in the planning phase of determining how to support Godot 4.0 and where we will focus our efforts in the future.<br />
You can follow <a href="https://github.com/godot-rust/godot-rust/issues/824">this GitHub issue</a> for updates.</p>
<h2 id="what-is-gdextension-why-arent-we-just-upgrading-gdnative"><a class="header" href="#what-is-gdextension-why-arent-we-just-upgrading-gdnative">What is GDExtension? Why aren't we just upgrading GDNative?</a></h2>
<p>The Godot team has officially announced <a href="https://godotengine.org/article/introducing-gd-extensions">GDExtension</a> as the <strong>replacement</strong> for GDNative. GDNative is no longer supported in Godot 4.</p>
<h2 id="what-do-we-know-so-far"><a class="header" href="#what-do-we-know-so-far">What do we know so far?</a></h2>
<p>Currently as there is limited documentation about how to implement <a href="https://godotengine.org/article/introducing-gd-extensions">GDExtension</a>, most of what we know is being explored via the <a href="https://github.com/godotengine/godot-cpp">Godot C++ bindings repo</a> and determining how to do the following:</p>
<ul>
<li>Generate the language bindings</li>
<li>How do we register classes with GDExtension along with the rest of the data?</li>
<li>How to migrate to the extensions.</li>
<li>Determine how this needs to integrate with Rust.</li>
<li>Which core types need to be reimplemented.</li>
</ul>
<p>In addition, we still need to start investigating and planning how the procedural macros need to be changed or rewritten to support a similar level of ergonomics that <code>gdnative</code> currently offers.</p>
<h2 id="how-can-i-help"><a class="header" href="#how-can-i-help">How can I help?</a></h2>
<p>We would be grateful for any help, please feel free to reach out to us on any of our <a href="https://godot-rust.github.io/community/">community platforms</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structuring-code-for-testing"><a class="header" href="#structuring-code-for-testing">Structuring Code for Testing</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-with-the-engine"><a class="header" href="#testing-with-the-engine">Testing with the Engine</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes">Recipes</a></h1>
<p>This is a small collection of recipes and patterns that various contributors have found to be useful with godot-rust.</p>
<p>These recipes cover general use cases and are not intended to be the <em>only</em> way to implement these patterns. Each recipe should be evaluated and customized to your specific use case.</p>
<p>The pages are listed alphabetically, so instead of reading them one-by-one, you can directly jump to those that appeal to you. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-async-with-tokio-runtime"><a class="header" href="#recipe-async-with-tokio-runtime">Recipe: Async with Tokio runtime</a></h1>
<p>This recipe is based off of the test written for <code>gdnative-async</code>, which uses the <code>futures</code> crate in the executor. For cases where you may need a <code>tokio</code> runtime, it is possible to execute spawned tokio tasks in much the same way, with some alterations.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>This recipe requires the following entries in your Cargo.toml file</p>
<pre><code class="language-toml">tokio = { version = &quot;1.10&quot;, features = [&quot;rt&quot;] }
gdnative = { git = &quot;https://github.com/godot-rust/godot-rust.git&quot;, features = [&quot;async&quot;]}
</code></pre>
<h2 id="defining-the-executor"><a class="header" href="#defining-the-executor">Defining the Executor</a></h2>
<p>The executor itself can be defined the same way.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread_local! {
	static EXECUTOR: &amp;'static SharedLocalPool = {
		Box::leak(Box::new(SharedLocalPool::default()))
	};
}
<span class="boring">}
</span></code></pre></pre>
<p>However, our <code>SharedLocalPool</code> will store a <code>LocalSet</code> instead, and the <code>futures::task::LocalSpawn</code> implementation for the type will simply spawn a local task from that.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task::LocalSet;

#[derive(Default)]
struct SharedLocalPool {
	local_set: LocalSet,
}

impl futures::task::LocalSpawn for SharedLocalPool {
	fn spawn_local_obj(
		&amp;self,
		future: futures::task::LocalFutureObj&lt;'static, ()&gt;,
	) -&gt; Result&lt;(), futures::task::SpawnError&gt; {
		self.local_set.spawn_local(future);

		Ok(())
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-executor-driver"><a class="header" href="#the-executor-driver">The Executor Driver</a></h2>
<p>Finally, we need to create a <code>NativeClass</code> which will act as the driver for our executor. This will store the tokio <code>Runtime</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::runtime::{Builder, Runtime};

#[derive(NativeClass)]
#[inherit(Node)]
struct AsyncExecutorDriver {
	runtime: Runtime,
}

impl AsyncExecutorDriver {
	fn new(_owner: &amp;Node) -&gt; Self {
		AsyncExecutorDriver {
			runtime: Builder::new_current_thread()
				.enable_io() 	// optional, depending on your needs
				.enable_time() 	// optional, depending on your needs
				.build()
				.unwrap(),
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>In the <code>_process</code> call of our <code>AsyncExecutorDriver</code>, we can block on <code>run_until</code> on the <code>LocalSet</code>. <code>run_until</code> will automatically resume all tasks on the local set until the provided future is completed. Since we don't want to block the frame, and we'd be checking every frame anyway, we just provide an empty task and await it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[methods]
impl AsyncExecutorDriver {
	#[export]
	fn _process(&amp;self, _owner: &amp;Node, _delta: f64) {
		EXECUTOR.with(|e| {
			self.runtime
				.block_on(async {
					e.local_set
						.run_until(async {
							tokio::task::spawn_local(async {}).await
						})
						.await
				})
				.unwrap()
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>From there, initializing is just the same as it is in the tests.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init(handle: InitHandle) {
	gdnative::tasks::register_runtime(&amp;handle);
	gdnative::tasks::set_executor(EXECUTOR.with(|e| *e));

	...
	handle.add_class::&lt;AsyncExecutorDriver&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-custom-node-plugin"><a class="header" href="#recipe-custom-node-plugin">Recipe: Custom node plugin</a></h1>
<p>While GDNative in Godot 3.x has some limitations, creating an <code>EditorPlugin</code> that registers custom nodes can be used to help integrate your types more tightly in the engine. Using a Custom Nodes plugin, you may register as many <code>NativeClass</code> scripts as you need in a single plugin.</p>
<ol>
<li>Create the directory &quot;res://addons/my_custom_nodes/&quot;.</li>
<li>In the directory &quot;res://addons/my_custom_nodes/&quot;, create <code>plugin.cfg</code> and <code>add_my_custom_nodes.gd</code> and include the following code for each.</li>
</ol>
<h2 id="plugincfg"><a class="header" href="#plugincfg">plugin.cfg</a></h2>
<pre><code class="language-ini">[plugin]
name=&quot;My Custom Nodes&quot;
description=&quot;Adds my custom nodes for my native classes.&quot;
author=&quot;your-name&quot;
version=&quot;0.1.0&quot;
script=&quot;add_my_custom_nodes.gd&quot;
</code></pre>
<h2 id="add_my_custom_nodesgd"><a class="header" href="#add_my_custom_nodesgd">add_my_custom_nodes.gd</a></h2>
<pre><code class="language-gdscript">tool
extends EditorPlugin

func _enter_tree():
    # Get the base icon from the current editor interface/theme
    var gui = get_editor_interface().get_base_control()
    var node_icon = gui.get_icon(&quot;Node&quot;, &quot;EditorIcons&quot;)
    
    # Alternatively, preload to a custom icon at the following
    # var node_icon preload(&quot;res://icon_ferris.png&quot;)

    add_custom_type(
        &quot;MyNode&quot;,
        &quot;Control&quot;,
        preload(&quot;res://gdnative/MyNode.gdns&quot;),
        node_icon
    )

    # Add any additional custom nodes here here.

func _exit_tree():
    remove_custom_type(&quot;MyNode&quot;)
    # Add a remove for each registered custom type to clean up
</code></pre>
<p>From the editor's main menu, find &quot;Project &gt; Project Settings &gt; Plugins&quot;. Find &quot;My Custom Nodes&quot; in the list of plugins and activate this. From here, you can create these directly from the &quot;Create New Node&quot; dialog. In addition, any nodes created this way will disallow the script from being changed or removed.</p>
<p>For more information about this kind of plugin, please refer to the <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/editor/making_plugins.html#a-custom-node">Godot Documentation</a>.</p>
<p><strong>Note</strong>: This method only works for types that inherit from <a href="https://docs.godotengine.org/en/stable/classes/class_script.html"><code>Script</code></a>. In addition, changing the path to the &quot;.gdns&quot; file will cause the custom <code>Node</code> to no longer register correctly.</p>
<p><strong>Note 2</strong>: This does not register your custom classes in the class database. In order to instantiate the script from GDScript, it will still be necessary to use <code>var ScriptType = preload(&quot;res://path/to/my_node.gdns&quot;)</code> before attempting to instantiate it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-loading-external-resource-files"><a class="header" href="#recipe-loading-external-resource-files">Recipe: Loading external resource files</a></h1>
<p>If you need to use any files that aren't explicitly supported by Godot's <a href="https://docs.godotengine.org/en/stable/classes/class_resourceloader.html">Resource Loader</a>, it will be necessary to process and load the file yourself.</p>
<p>This recipe covers two methods of loading these files.</p>
<h2 id="option-1---embed-the-file-into-the-binary"><a class="header" href="#option-1---embed-the-file-into-the-binary">Option 1 - Embed the File into the Binary</a></h2>
<p>The simplest way is to embed the resource directly into your binary by using the <code>std::include_bytes</code> macro.</p>
<p>To embed the file directly into the binary you can use the following macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// To have global immutable access to the file.
const RESOURCE: &amp;'static [u8] = include_bytes!(&quot;path/to/resource/file&quot;);

fn process_the_resource() {
    // Include the file locally
    let bytes = include_bytes!(&quot;path/to/resource/file&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>This can be useful for embedding any information that should be included at build time.</p>
<p>For example: such as if you wish to hard-code certain features like cheat codes, developer consoles, or default user configuration as a file rather than a build flag.</p>
<p>This approach is much more limited as it requires recompiling for all targets whenever changes to the resources are made.</p>
<h2 id="option-2---embed-the-file-in-the-pck"><a class="header" href="#option-2---embed-the-file-in-the-pck">Option 2 - Embed the File in the PCK</a></h2>
<p>For most other use-cases you can use Godot's PCK file to export your resources into the game.</p>
<p>This can be accomplished by using the <code>gdnative::api::File</code> module as follows.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn load_resource_as_string(filepath: &amp;str) -&gt; String {
    use gdnative::api::File;
    let file = File::new();
    file.open(filepath, File::READ).expect(&amp;format!(&quot;{} must exist&quot;, filepath));
    
    let data: GodotString = file.get_as_text();
    // Depending upon your use-case you can also use the following methods depending upon your use-case.
    // let line: StringArray = file.get_csv_line(0);
    // let file_len = file.get_len();
    // let bytes: ByteArray = file.get_bytes(file_len);
    data.to_string()
}
<span class="boring">}
</span></code></pre></pre>
<p>See the <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.File.html"><code>File</code> Class Documentation</a> for every function that you use for loading the resources.</p>
<p>After you retrieve the data in the desired format, you can process it like you would normal Rust code.</p>
<h2 id="option-3-save-and-load-filedata-as-user_data"><a class="header" href="#option-3-save-and-load-filedata-as-user_data">Option #3 Save and Load filedata as user_data</a></h2>
<p>Godot allows access to device side user directory for the project under &quot;user://&quot;. This works very similar to loading above and it uses the <code>gdnative::api::File</code> API</p>
<p>Note: Saving only works on resource paths (paths starting with &quot;res://&quot;) when Godot is being run in the editor. After exporting &quot;res://&quot; becomes read-only.</p>
<p>Example on writing and reading string data.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_data_from_string(filepath: &amp;str, data: &amp;str) {
    use gdnative::api::File;
    let file = File::new();
    file.open(filepath, File::WRITE).expect(&amp;format!(&quot;{} must exist&quot;, &amp;filepath));
    
    file.store_string(data);
}


fn load_data_as_string(filepath: &amp;str) -&gt; String {
    use gdnative::api::File;
    let file = File::new();
    file.open(filepath, File::READ).expect(&amp;format!(&quot;{} must exist&quot;, &amp;filepath));
    
    let data: GodotString = file.get_as_text();
    data.to_string()
}
<span class="boring">}
</span></code></pre></pre>
<p>For more information on the paths, please refer to the <a href="https://docs.godotengine.org/en/3.0/getting_started/step_by_step/filesystem.html#resource-path">File System Tutorial</a>.</p>
<h3 id="testing-1"><a class="header" href="#testing-1">Testing</a></h3>
<p>This section is for unit testing from Rust without loading Godot. As <code>gdnative::api::File</code> requires that Godot be running, any Rust-only unit tests will require a separate method to be implemented in order to load the resources. This can be accomplished by creating separate code paths or functions <code>#[cfg(test)]</code> and <code>#[cfg(not(test))]</code> attributes to differentiate between test configuration and Godot library configurations.</p>
<p>In test configurations, you will need to ensure that your loading code uses <code>std::fs::File</code> or some equivalent to read your load.</p>
<h3 id="exporting"><a class="header" href="#exporting">Exporting</a></h3>
<p>When exporting your game, under the <code>Resources</code> Tab you will need to add a filter so that godot will pack those resources into the .pck file.</p>
<p>For example: If you are using .json, .csv and .ron files, you will need to use include <code>*.json, *.csv, *.ron</code> in the &quot;Filters to Export non-resource files/folders&quot; field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-logging"><a class="header" href="#recipe-logging">Recipe: Logging</a></h1>
<p>Logging in Godot can be accessed by using the <code>godot_print!</code>, <code>godot_warn!</code>, and <code>godot_error!</code> macros.</p>
<p>These macros only work when the library is loaded by Godot. They will panic instead when invoked outside that context, for example, when the crate is being tested with cargo test</p>
<h2 id="simple-wrapper-macros-for-test-configurations"><a class="header" href="#simple-wrapper-macros-for-test-configurations">Simple wrapper macros for test configurations</a></h2>
<p>The first option that you have is wrap the <code>godot_print!</code> macros in the following macro that will use <code>godot_print!</code> when running with Godot, and stdout when run during tests.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// prints to Godot's console, except in tests, there it prints to stdout
macro_rules! console_print {
    ($($args:tt)*) =&gt; ({
        if cfg!(test) {
            println!($($args)*);
        } else {
            gdnative::godot_print!($($args)*);
        }
    });
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-a-logging-crate"><a class="header" href="#using-a-logging-crate">Using a logging Crate</a></h2>
<p>A more robust solution is to integrate an existing logging library.</p>
<p>This recipe demonstrates using the <code>log</code> crate with <code>flexi-logger</code>. While most of this guide will work with other backends, the initialization and <code>LogWriter</code> implementation may differ.</p>
<p>First add the following crates to your <code>Cargo.toml</code> file. You may want to check the crates.io pages of the crates for any updates.</p>
<pre><code class="language-toml">log = &quot;0.4.14&quot;
flexi_logger = &quot;0.17.1&quot;
</code></pre>
<p>Then, write some code that glues the logging crates with Godot's logging interface. <code>flexi-logger</code>, for example, requires a <code>LogWriter</code> implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;
use flexi_logger::writers::LogWriter;
use flexi_logger::{DeferredNow, Record};
use log::{Level, LevelFilter};

pub struct GodotLogWriter {}

impl LogWriter for GodotLogWriter {
    fn write(&amp;self, _now: &amp;mut DeferredNow, record: &amp;Record) -&gt; std::io::Result&lt;()&gt; {
        match record.level() {
            // Optionally push the Warnings to the godot_error! macro to display as an error in the Godot editor.
            flexi_logger::Level::Error =&gt; godot_error!(&quot;{}:{} -- {}&quot;, record.level(), record.target(), record.args()),
            // Optionally push the Warnings to the godot_warn!  macro to display as a warning in the Godot editor.
            flexi_logger::Level::Warn =&gt; godot_warn!(&quot;{}:{} -- {}&quot;,record.level(), record.target(), record.args()),
            _ =&gt; godot_print!(&quot;{}:{} -- {}&quot;, record.level(), record.target(), record.args())
        }        ;
        Ok(())
    }

    fn flush(&amp;self) -&gt; std::io::Result&lt;()&gt; {
        Ok(())
    }

    fn max_log_level(&amp;self) -&gt; LevelFilter {
        LevelFilter::Trace
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For the logger setup, place the code logger configuration code in your <code>fn init(handle: InitHandle)</code> as follows.</p>
<p>To add the logging configuration, you need to add the initial configuration and start the logger inside the init function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init(handle: InitHandle) {
    flexi_logger::Logger::with_str(&quot;trace&quot;)
        .log_target(flexi_logger::LogTarget::Writer(Box::new(crate::util::GodotLogWriter {})))
        .start()
        .expect(&quot;the logger should start&quot;);
    /* other initialization work goes here */ 
}
godot_init!(init);
<span class="boring">}
</span></code></pre></pre>
<h3 id="setting-up-a-log-target-for-tests"><a class="header" href="#setting-up-a-log-target-for-tests">Setting up a log target for tests</a></h3>
<p>When running in a test configuration, if you would like logging functionality, you will need to initialize a log target.</p>
<p>As tests are run in parallel, it will be necessary to use something like the following code to initialize the logger only once. The <code>#[cfg(test)]</code> attributes are used to ensure that this code is not accessible outside of test builds.</p>
<p>Place this in your crate root (usually lib.rs)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
use std::sync::Once;
#[cfg(test)]
static TEST_LOGGER_INIT: Once = Once::new();
#[cfg(test)]
fn test_setup_logger() {
    TEST_LOGGER_INIT.call_once(||{
        flexi_logger::Logger::with_str(&quot;debug&quot;)
        .log_target(flexi_logger::LogTarget::StdOut)
        .start()
        .expect(&quot;the logger should start&quot;);
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>You can call the above code in your units tests with <code>crate::test_setup_logger()</code>. Please note: currently there does not appear to be a tes case that will be called before tests are configured, so the <code>test_setup_logger</code> will need to be called in every test where you require log output.</p>
<p>Now that the logging is configured, you can use use it in your code such as in the following sample</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>log::trace!(&quot;trace message: {}&quot;, &quot;message string&quot;);
log::debug!(&quot;debug message: {}&quot;, &quot;message string&quot;);
log::info!(&quot;info message: {}&quot;, &quot;message string&quot;);
log::warn!(&quot;warning message: {}&quot;, &quot;message string&quot;);
log::error!(&quot;error message: {}&quot;, &quot;message string&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>At this point, we have a logging solution implemented for our Rust based code that will pipe the log messages to Godot.</p>
<p>But what about GDScript? It would be nice to have consistent log messages in both GDScript and GDNative. One way to ensure that is to expose the logging functionality to Godot with a <code>NativeClass</code>.</p>
<h3 id="exposing-to-gdscript"><a class="header" href="#exposing-to-gdscript">Exposing to GDScript</a></h3>
<blockquote>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>As the Rust macros cannot get the GDScript name or resource_path, it is necessary to pass the log target from GDScript.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Copy, Clone, Default)]
#[user_data(Aether&lt;DebugLogger&gt;)]
#[inherit(Node)]
pub struct DebugLogger;

#[methods]
impl DebugLogger {
    fn new(_: &amp;Node) -&gt; Self {
        Self {}
    }
    #[export]
    fn error(&amp;self, _owner: &amp;Node, target: String, message: String) {
        log::error!(target: &amp;target, &quot;{}&quot;, message);
    }
    #[export]
    fn warn(&amp;self, _: &amp;Node, target: String, message: String) {
        log::warn!(target: &amp;target, &quot;{}&quot;, message);
    }
    #[export]
    fn info(&amp;self, _: &amp;Node, target: String, message: String) {
        log::info!(target: &amp;target, &quot;{}&quot;, message);
    }
    #[export]
    fn debug(&amp;self, _: &amp;Node, target: String, message: String) {
        log::debug!(target: &amp;target, &quot;{}&quot;, message);
    }
    #[export]
    fn trace(&amp;self, _: &amp;Node, target: String, message: String) {
        log::trace!(target: &amp;target, &quot;{}&quot;, message);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After adding the class above with <code>handle.add_class::&lt;DebugLogger&gt;()</code> in the <code>init</code> function, you may add it as an Autoload Singleton in your project for easy access. In the example below, the name &quot;game_logger&quot; is chosen for the Autoload singleton:</p>
<pre><code class="language-gdscript">game_logger.trace(&quot;name_of_script.gd&quot;, &quot;this is a trace message&quot;)
game_logger.debug(&quot;name_of_script.gd&quot;, &quot;this is a debug message&quot;)
game_logger.info(&quot;name_of_script.gd&quot;, &quot;this is an info message&quot;)
game_logger.warn(&quot;name_of_script.gd&quot;, &quot;this is a warning message&quot;)
game_logger.error(&quot;name_of_script.gd&quot;, &quot;this is an error message&quot;)
</code></pre>
<p>As this is not very ergonomic, it is possible to make a more convenient access point that you can use in your scripts. To make the interface closer to the Rust one, we can create a <code>Logger</code> class in GDScript that will call the global methods with the name of our script class.</p>
<pre><code class="language-gdscript">extends Reference

class_name Logger

var _script_name

func _init(script_name: String) -&gt; void:
	self._script_name = script_name

func trace(msg: String) -&gt; void:
	D.trace(self._script_name, msg)
	
func debug(msg: String) -&gt; void:
	D.debug(self._script_name, msg)

func info(msg: String) -&gt; void:
	D.info(self._script_name, msg)

func warn(msg: String) -&gt; void:
	D.warn(self._script_name, msg)

func error(msg: String) -&gt; void:
	D.error(self._script_name, msg)
</code></pre>
<p>To use the above class, create an instance of <code>Logger</code> in a local variable with the desired <code>script_name</code> and use it as in the script example below:</p>
<pre><code class="language-gdscript">extends Node

var logger = Logger.new(&quot;script_name.gd&quot;)

func _ready() -&gt; void:
    logger.info(&quot;_ready&quot;)
</code></pre>
<p>And now you have a logging solution fully implemented in Rust and usable in GDScript.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-nix-as-development-environment"><a class="header" href="#recipe-nix-as-development-environment">Recipe: Nix as development environment</a></h1>
<p><strong>Disclaimer</strong>: <em>Currently the following steps are tested and confirmed to work on Linux only.</em></p>
<p><a href="https://nixos.org/">Nix</a> is a package manager that employs a pure functional approach to dependency management. Nix packages are built and ran in isolated environments. It makes them more portable, but also harder to author. This tutorial will walk you through the process of setting up a package for Godot, GDNative and Rust with Nix.</p>
<p>This tutorial assumes that Nix is <a href="https://nixos.org/download.html#nix-quick-install">installed</a> in your system.</p>
<p>To begin with, we are going to create a new project using the <a href="recipes/../getting-started/hello-world.html">Hello, world!</a> guide in Getting Started. Note that the full source code for the project is available at https://github.com/godot-rust/godot-rust/tree/master/examples/hello-world. Because we aren't using the default build system explained in <a href="recipes/../getting-started/setup.html">setup</a>, you should only be worried about the content of the project rather than the dependencies.</p>
<h2 id="specifying-dependencies"><a class="header" href="#specifying-dependencies">Specifying dependencies</a></h2>
<p>Now to the Nix part of the tutorial. In the root directory of the project (where <code>project.godot</code> is located), create a new file called <code>shell.nix</code>. Later on, this file will be evaluated by Nix to define the dependencies of your project. Below are the default content of <code>shell.nix</code> to run the sample project. We will also explain it in brief about the meaning each line of code.</p>
<pre><code class="language-nix">let
    # Get an up-to-date package for enabling OpenGL support in Nix
    nixgl = import (fetchTarball &quot;https://github.com/guibou/nixGL/archive/master.tar.gz&quot;) {};

    # Pin the version of the nix package repository that has Godot 3.2.3 and compatible with godot-rust 0.9.3
    # You might want to update the commit hash into the one that have your desired version of Godot
    # You could search for the commit hash of a particular package by using this website https://lazamar.co.uk/nix-versions
    pkgs = import (fetchTarball &quot;https://github.com/nixos/nixpkgs/archive/5658fadedb748cb0bdbcb569a53bd6065a5704a9.tar.gz&quot;) {};
in
    # Configure the dependency of your shell
    # Add support for clang for bindgen in godot-rust
    pkgs.mkShell.override { stdenv = pkgs.clangStdenv; } {
        buildInputs = [
            # Rust related dependencies
            pkgs.rustc
            pkgs.cargo
            pkgs.rustfmt
            pkgs.libclang

            # Godot Engine Editor
            pkgs.godot

            # The support for OpenGL in Nix
            nixgl.nixGLDefault
        ];

        # Point bindgen to where the clang library would be
        LIBCLANG_PATH = &quot;${pkgs.libclang.lib}/lib&quot;;

        # For Rust language server and rust-analyzer
        RUST_SRC_PATH = &quot;${pkgs.rust.packages.stable.rustPlatform.rustLibSrc}&quot;;

        # Alias the godot engine to use nixGL
        shellHook = ''
            alias godot=&quot;nixGL godot -e&quot;
        '';
    }
</code></pre>
<h2 id="activating-the-nix-environment"><a class="header" href="#activating-the-nix-environment">Activating the Nix environment</a></h2>
<p>One of the simplest way to activate the nix environment is to use the <code>nix-shell</code> command. This program is installed automatically as you install Nix Package Manager.</p>
<p>First, you need to open the root directory of your project. And then to activate your environment, run <code>nix-shell -v</code> into your terminal. The optional <code>-v</code> flag in the command will configure the command to be more verbose and display what kinds of things is getting installed. Because this is your first time using <code>nix-shell</code> on this particular project, it will take some time to download and install all the required dependencies. Subsequent run will be a lot faster after the installation.</p>
<p>To run the project, first you need to compile the <code>hello-world</code> Rust library using <code>cargo build</code>. After that, you can open the Godot Engine in your terminal using the command <code>godot</code>. As seen in <code>shell.nix</code>, this command is actually aliased to <code>nixGL godot -e</code> in which Godot will be opened using nixGL instead of opening it directly. After running the default scene, you should be able to see a single <code>hello, world.</code> printed in the Godot terminal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-rust-panic-handler"><a class="header" href="#recipe-rust-panic-handler">Recipe: Rust panic handler</a></h1>
<p>When using GDNative, Rust panics are ignored by Godot by default. This recipe can be used to catch those panics in the Godot editor at runtime.</p>
<p>This recipe was written and tested with godot-rust 0.9.3 with Rust version 1.52.1</p>
<h2 id="gdscript-hook"><a class="header" href="#gdscript-hook">GDScript hook</a></h2>
<p>First create a GDScript with the following code named &quot;rust_panic_hook.gd&quot;</p>
<pre><code>extends Node

func rust_panic_hook(error_msg: String) -&gt; void:
	assert(false, error_msg)

</code></pre>
<p>In the Project Settings -&gt; Autoload menu, create an autoload singleton referencing the script (in this case rust_panic_hook.gd).</p>
<p>Pick a unique name that identifies the autoload singleton. You will need to use this name to find the autoload singleton in Rust.</p>
<p>For this example, we are using the autoload name &quot;rust_panic_hook&quot;.</p>
<p>At this point we have our GDScript based  panic hook we can use in Rust.</p>
<h2 id="gdnative-hook-initialization"><a class="header" href="#gdnative-hook-initialization">GDNative hook initialization</a></h2>
<p>In the GDNative library code's entry point (lib.rs by default).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init_panic_hook() {
    // To enable backtrace, you will need the `backtrace` crate to be included in your cargo.toml, or 
    // a version of Rust where backtrace is included in the standard library (e.g. Rust nightly as of the date of publishing)
    // use backtrace::Backtrace;
    // use std::backtrace::Backtrace;
    let old_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |panic_info| {
        let loc_string;
        if let Some(location) = panic_info.location() {
            loc_string = format!(&quot;file '{}' at line {}&quot;, location.file(), location.line());
        } else {
            loc_string = &quot;unknown location&quot;.to_owned()
        }

        let error_message;
        if let Some(s) = panic_info.payload().downcast_ref::&lt;&amp;str&gt;() {
            error_message = format!(&quot;[RUST] {}: panic occurred: {:?}&quot;, loc_string, s);
        } else if let Some(s) = panic_info.payload().downcast_ref::&lt;String&gt;() {
            error_message = format!(&quot;[RUST] {}: panic occurred: {:?}&quot;, loc_string, s);
        } else {
            error_message = format!(&quot;[RUST] {}: unknown panic occurred&quot;, loc_string);
        }
        godot_error!(&quot;{}&quot;, error_message);
        // Uncomment the following line if backtrace crate is included as a dependency
        // godot_error!(&quot;Backtrace:\n{:?}&quot;, Backtrace::new());
        (*(old_hook.as_ref()))(panic_info);

        unsafe {
            if let Some(gd_panic_hook) = gdnative::api::utils::autoload::&lt;gdnative::api::Node&gt;(&quot;rust_panic_hook&quot;) {
                gd_panic_hook.call(&quot;rust_panic_hook&quot;, &amp;[GodotString::from_str(error_message).to_variant()]);
            }
        }
    }));
}
<span class="boring">}
</span></code></pre></pre>
<p>The details the process in the above code is as follows:</p>
<ol>
<li>Get the default panic hook from Rust</li>
<li>Create a new panic hook closure to output to the Godot console</li>
<li>Get the location string and error message from the <code>panic_info</code> closure parameter and print the message to the console</li>
<li>Optionally, retreive and print the backtrace</li>
<li>Execute the old panic hook so that the normal panic behavior still occurs</li>
<li>Call the function defined on your GDScript panic hook script</li>
</ol>
<p>The final step is to call <code>init_panic_hook()</code> at the end of the <code>init</code> function that you pass in the <code>godot_init(init)</code> macro such as in the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GDNative entry point
fn init(handle: InitHandle) {
    // -- class registration above
    init_panic_hook();
}
<span class="boring">}
</span></code></pre></pre>
<p>Now you can run your game and once it is fully initialized, any panics will pause the game execution and print the panic message in Godot's editor in the Debugger's Error tab.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="third-party-projects"><a class="header" href="#third-party-projects">Third-party projects</a></h1>
<p>This chapter intends to provide an overview over the godot-rust ecosystem and list projects that use godot-rust across different domains.</p>
<p>godot-rust is a popular choice for game development, but this chapter is not limited to games. We also list other applications, as well as tooling and libraries that extend godot-rust and integrate it with other parts of the ecosystem.</p>
<p>While part of the book, this chapter is <em>not</em> an official list of &quot;featured&quot; entries; project authors themselves are responsible for the up-to-dateness and accuracy of their description. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projects-games"><a class="header" href="#projects-games">Projects: Games</a></h1>
<p>Below you see a non-exhaustive list of games that have been developed with godot-rust.</p>
<p>The page focuses on entries which are either in a playable state, or at least have some basic mechanics and graphics to show. For example, such an entry could be an indie game developed over many months, or also a polished game jam submission. The condition is that a notable part of the game is written in godot-rust, however it doesn't need to be the majority. For example, <a href="projects/../gdnative-overview/architecture.html">one of the common architectures</a> entails using Rust for selective modules.</p>
<h3 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of contents</a></h3>
<ul>
<li><a href="projects/games.html#the-recall-singularity">The Recall Singularity</a></li>
<li><a href="projects/games.html#the-process">The Process</a></li>
<li><a href="projects/games.html#bitgun">BITGUN</a></li>
<li><a href="projects/games.html#bendyworm">BENDYWORM</a></li>
<li><a href="projects/games.html#cake-thieves">Cake Thieves</a></li>
</ul>
<h2 id="the-recall-singularity"><a class="header" href="#the-recall-singularity">The Recall Singularity</a></h2>
<p><em>by <strong>Jump to Warp</strong> (Tom Leys)</em><br />
🕊️ <em><a href="https://twitter.com/RecallSingular1">@RecallSingular1</a></em></p>
<p><img src="projects/img/the-recall-singularity.jpg" alt="" /></p>
<p>The Recall Singularity is a factory game, set within a player-controlled fleet of space-ships.<br />
Players blast asteroids, collect rocks, grind them up and turn them into ship parts. </p>
<h2 id="the-process"><a class="header" href="#the-process">The Process</a></h2>
<p><em>by <strong>setzer22</strong></em><br />
🕊️ <em><a href="https://twitter.com/PlayTheProcess">@PlayTheProcess</a></em></p>
<p><img src="projects/img/the-process.jpg" alt="" /></p>
<p>The Process is an upcoming game about factory building, process management, and carrot production, built with godot-rust!</p>
<p>The game offers a similar experience to other titles in the factory building genre (Factorio, Satisfactory), but is more tailored towards a chill, lighthearted atmosphere.</p>
<h2 id="bitgun"><a class="header" href="#bitgun">BITGUN</a></h2>
<p><em>by <strong>LogLogGames</strong></em><br />
🕹️ <em><a href="https://store.steampowered.com/app/1673940/BITGUN"><strong>Steam</strong></a></em> | 🕊️ <em><a href="https://twitter.com/LogLogGames">@LogLogGames</a></em> | 🌐 <em><a href="https://loglog.games">Website</a></em></p>
<p><img src="projects/img/bitgun.jpg" alt="" /></p>
<p>BITGUN is an action roguelike zombie shooter with lots of blood and guns.</p>
<h2 id="bendyworm"><a class="header" href="#bendyworm">BENDYWORM</a></h2>
<p><em>by <strong>Bauxitedev</strong></em><br />
🕹️ <em><a href="https://bauxite.itch.io/bendyworm"><strong>itch.io</strong></a></em> | 🕊️ <em><a href="https://twitter.com/bauxitedev">@bauxitedev</a></em> | 📜 <em><a href="https://github.com/Bauxitedev/bendyworm">GitHub</a> (game is open-source)</em></p>
<p><img src="projects/img/bendyworm.png" alt="" /></p>
<p>BENDYWORM is a platformer with a twist: the entire world bends and twists around you as you progress through the level. Why? Because you're inside of a gigantic worm, and worms are bendy. Navigate the worm's slippery innards, collect the Mega Cannon, and destroy its brain to escape!</p>
<h2 id="cake-thieves"><a class="header" href="#cake-thieves">Cake Thieves</a></h2>
<p><em>by <strong>GeTech</strong></em><br />
🕹️ <em><a href="https://play.google.com/store/apps/details?id=com.GeTech.CakeThieves"><strong>Google Play</strong></a></em> | 🕊️ <em><a href="https://twitter.com/GeTech8">@GeTech8</a></em></p>
<p><img src="projects/img/cake-thieves.jpg" alt="" /></p>
<p>Thieves have found your picnic and want to eat your delicious cake! Protect it by placing cannons on the field to defeat the ants. Improve your cannons to increase their power! How well will you do in this challenge?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projects-tools-and-integrations"><a class="header" href="#projects-tools-and-integrations">Projects: Tools and integrations</a></h1>
<p>This page lists projects, which are intended to be used as an extension to godot-rust.<br />
Examples include:</p>
<ul>
<li>CLI or other tools enhancing the development workflow</li>
<li>Libraries that directly enhance the godot-rust experience</li>
<li>Libraries that connect godot-rust with other crates in the Rust ecosystem</li>
</ul>
<p>This page should only provide a high-level description of each project (a couple sentences), plus relevant links and optionally one screenshot. It should <em>not</em> include tutorials or extended code examples, as they tend to become outdated very quickly. Instead, the project's repository or homepage is a much better place for advertising the concrete functionality the tool offers and providing introductory examples.</p>
<h3 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of contents</a></h3>
<ul>
<li><a href="projects/tools.html#godot-egui">godot-egui</a></li>
<li><a href="projects/tools.html#godot-rust-cli">godot-rust-cli</a></li>
<li><a href="projects/tools.html#ftw">ftw</a></li>
<li><a href="projects/tools.html#gdrust">gdrust</a></li>
</ul>
<h2 id="godot-egui"><a class="header" href="#godot-egui">godot-egui</a></h2>
<p><em><a href="https://github.com/setzer22/godot-egui">GitHub</a></em></p>
<p><img src="projects/img/godot-egui.gif" alt="" /></p>
<p><strong>godot-egui</strong> is an <a href="https://github.com/emilk/egui">egui</a> backend for godot-rust. </p>
<p>This crate enables using the immediate-mode UI library egui within Godot applications and games. Updating UI widgets and properties directly from Rust code becomes straightforward, without going through Godot nodes, signals and the intricacies of GDNative's ownership semantics.</p>
<h2 id="godot-rust-cli"><a class="header" href="#godot-rust-cli">godot-rust-cli</a></h2>
<p><em><a href="https://github.com/robertcorponoi/godot-rust-cli">GitHub</a></em></p>
<p><strong>Godot Rust CLI</strong> is a simple command-line interface to help you create and update Rust components for your Godot projects.</p>
<p>Example:</p>
<pre><code class="language-sh"># create a Rust library `rust_modules` for the `platformer` Godot project
godot-rust-cli new rust_modules platformer

# create player.rs + player.gdns
godot-rust-cli create Player 

# generate dynamic library to be called by Godot, automatically watch changes
godot-rust-cli build --watch
</code></pre>
<p>Note that there is also <a href="https://github.com/robertcorponoi/godot-rust-cli-upgrader">godot-rust-cli-upgrader</a> to upgrade the CLI.</p>
<h2 id="ftw"><a class="header" href="#ftw">ftw</a></h2>
<p><em><a href="https://github.com/macalimlim/ftw">GitHub</a></em></p>
<p><strong>ftw</strong> is a command-line interface to manage your godot-rust project. It enables you to set up projects, add native classes which are automatically wired up, and run build commands.</p>
<p>Example:</p>
<pre><code class="language-sh"># create new project using the default template
ftw new my-awesome-game

# create a class that derives from `Area2D`
ftw class MyHero Area2D

# create a class called `MySingleton` that derives from `Node`
ftw singleton MySingleton
 
# build the library for the `linux-x86_64` platform using `debug` as default
ftw build linux-x86_64
</code></pre>
<h2 id="gdrust"><a class="header" href="#gdrust">gdrust</a></h2>
<p><em><a href="https://github.com/wyattjsmith1/gdrust">GitHub</a></em></p>
<p><strong>gdrust</strong> is a an extension library to godot-rust. It adds ergonomic improvements and is an inspiration for godot-rust itself.</p>
<p>Example:</p>
<pre><code class="language-rs">#[gdrust]
#[signal(signal_name(arg_name: I64, arg2_name: F64 = 10.0))]
struct MyClass {
    #[export_range(1, 10, 2, &quot;or_greater&quot;)]
    my_range: i32,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projects-applications"><a class="header" href="#projects-applications">Projects: Applications</a></h1>
<p>This page lists non-game applications developed with godot-rust. Libraries should be listed in <a href="projects/tools.html">Tools</a>.
Examples here include:</p>
<ul>
<li>Tech demos</li>
<li>User interfaces</li>
<li>Data visualization</li>
</ul>
<h2 id="todo-add-project"><a class="header" href="#todo-add-project">(TODO: add project)</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exporting-1"><a class="header" href="#exporting-1">Exporting</a></h1>
<p>Exporting <a href="https://godotengine.org/">Godot</a> projects using <a href="https://github.com/godot-rust/godot-rust">godot-rust</a>
is a 2 steps process:</p>
<ul>
<li>build your Rust code with cargo, which triggers a build of <a href="https://crates.io/crates/gdnative">gdnative crate</a> for the target platform;</li>
<li>do a standard <a href="https://docs.godotengine.org/en/stable/getting_started/workflow/export/exporting_projects.html">Godot export</a>.</li>
</ul>
<p>If the target you are exporting to is the same as the one you are developping on,
the export is straightforward, however when cross-compiling (eg: exporting for a mobile platform,
or building from a Docker image on a CI)
you need to correctly set up a cross-compiler for the target platform. Rust does this very well,
so provided you only write Rust code, cross-compiling is easy.
However to build <a href="https://crates.io/crates/gdnative-sys">gdnative-sys</a> you need a working C/C++
cross compiler with, among other things, the correct headers and linker.</p>
<p>How to set up such a cross-compiler depends on the source and the target platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p><strong>Disclaimer</strong>: <em>Currently, the following steps are tested and confirmed to work on Linux only.</em></p>
<p>In order to export to Android, we need to compile our Rust source for the appropriate targets. Unlike compiling for our native targets, there are a few extra steps involved with cross-compiling for another target.</p>
<h2 id="installing-prerequisites"><a class="header" href="#installing-prerequisites">Installing prerequisites</a></h2>
<p>First, we need to install the <strong>Android SDK</strong> with <strong>NDK</strong> enabled. This contains the necessary tools for each architecture. Once the Android SDK is installed, open Editor Settings in the Godot GUI (<em>Editor &gt; Editor Settings &gt; Export &gt; Android</em>) and set the <strong>absolute paths</strong> to <code>adb</code>, <code>jarsigner</code>, and the debug keystore (<code>debug.keystore</code>), all of which can be found in the Android SDK installation.</p>
<p>Then, we'll install the Rust toolchains for the targets we want to support:</p>
<pre><code class="language-bash">rustup target add aarch64-linux-android    # for arm64 (64-bit)
rustup target add x86_64-linux-android     # for x86_64 (64-bit)
</code></pre>
<h3 id="32-bit-targets"><a class="header" href="#32-bit-targets">32-bit targets</a></h3>
<p>The <code>aarch64-linux-android</code> and <code>x86_64-linux-android</code> toolchains are our top priorities, because Google <a href="https://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html">has been requiring 64-bit binaries</a> for all new apps on Play Store since August 2019, and will stop serving 32-bit apps in 2021. If you, nevertheless, want to support 32-bit targets, there are a few more dependencies to install.</p>
<blockquote>
<h3 id="a-bit-of-context"><a class="header" href="#a-bit-of-context">A bit of context</a></h3>
<p>There are two major CPU providers in the Android ecosystem: ARM and Intel.</p>
<p>They were primarily supporting 32-bit OS, with notably <a href="https://en.wikipedia.org/wiki/ARM_architecture#32-bit_architecture"><strong>ARMv7</strong></a> and <a href="https://en.wikipedia.org/wiki/X86"><strong>x86</strong></a> architectures, until they started supporting 64-bit OS, by introducing <a href="https://en.wikipedia.org/wiki/ARM_architecture#64/32-bit_architecture"><strong>ARMv8-A</strong></a> (often called <strong>ARM64</strong>) and <a href="https://en.wikipedia.org/wiki/X86-64"><strong>x86-64</strong></a> (often called <strong>Intel 64</strong> or <strong>AMD64</strong>, in reference to a <a href="https://en.wikipedia.org/wiki/X86-64#History_2">long-time conflict</a> between Intel and AMD).</p>
<p><strong>Aarch64</strong> is the 64-bit execution state that is introduced in ARM64 chips. <a href="https://en.wikipedia.org/wiki/P6_%28microarchitecture%29"><strong>i686</strong></a> (also called <strong>P6</strong>) is actually the sixth-generation Intel x86 microarchitecture.</p>
<p>Generally speaking, 32-bit programs can run on 64-bit systems, but 64-bit programs won't run on 32-bit systems.</p>
</blockquote>
<h4 id="rust-toolchains-for-32-bit-targets"><a class="header" href="#rust-toolchains-for-32-bit-targets">Rust toolchains for 32-bit targets</a></h4>
<pre><code class="language-bash">rustup target add armv7-linux-androideabi  # for armv7 (32-bit)
rustup target add i686-linux-android       # for x86 (32-bit)
</code></pre>
<h4 id="gcc-libraries-for-cross-compilation"><a class="header" href="#gcc-libraries-for-cross-compilation"><code>gcc</code> libraries for cross-compilation</a></h4>
<p>On Windows, we will need to setup a <a href="https://sourceforge.net/projects/mingw-w64/">32-bit/64-bit compatible MinGW</a> instance.</p>
<p>On UNIX-like systems, the required packages are usually available under different names in the package managers for each distribution. On Debian-based Linuxes (including Ubuntu), for example, the required libraries can be installed using <code>apt</code>:</p>
<pre><code class="language-bash">apt-get update
apt-get install g++-multilib gcc-multilib libc6-dev-i386 -y
</code></pre>
<h2 id="setting-up-cargo"><a class="header" href="#setting-up-cargo">Setting up Cargo</a></h2>
<p>To make Cargo aware of the proper platform-specific linkers that it needs to use for Android targets, we need to put the paths to the binaries in the Cargo configuration file, which can be found (or created) at <code>$HOME/.cargo/config</code> on UNIX-like systems, or <code>%USERPROFILE%\.cargo\config</code> on Windows), using <a href="https://doc.rust-lang.org/cargo/reference/config.html#targettriplelinker"><code>[target]</code> tables</a>:</p>
<pre><code class="language-toml">[target.armv7-linux-androideabi]
linker = &quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi29-clang&quot;
</code></pre>
<p>... where the value of <code>linker</code> is an <strong>absolute path</strong> to the Android SDK linker for the target triple. Assuming <code>$ANDROID_SDK_ROOT</code> is the Android SDK path and <code>$ANDROID_NDK_VERSION</code> is the installed NDK instance version, these binaries can be found at:</p>
<ul>
<li>Windows: <code>$ANDROID_SDK_ROOT\ndk\$ANDROID_NDK_VERSION\toolchains\llvm\prebuilt\windows-x86_64\bin\</code></li>
<li>UNIX-like systems: <code>$ANDROID_SDK_ROOT/ndk/$ANDROID_NDK_VERSION/toolchains/llvm/prebuilt/linux-x86_64/bin/</code></li>
</ul>
<blockquote>
<p>Alternatively, the NDK can be located under <code>$ANDROID_SDK_ROOT/ndk-bundle</code> instead of <code>$ANDROID_SDK_ROOT/ndk/$ANDROID_NDK_VERSION</code>, but this folder is deprecated because it doesn't allow for parallel versions installation.</p>
</blockquote>
<p>Repeat for all targets installed in the previous step, until we get something that looks like:</p>
<pre><code class="language-toml"># Example configuration on an UNIX-like system. `29` is the Android API version.

[target.armv7-linux-androideabi]
linker = &quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi29-clang&quot;

[target.aarch64-linux-android]
linker = &quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android29-clang&quot;

[target.i686-linux-android]
linker = &quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/i686-linux-android29-clang&quot;

[target.x86_64-linux-android]
linker = &quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android29-clang&quot;
</code></pre>
<p>Alternatively, you can use cargo config environment variables:</p>
<pre><code class="language-bash">export CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER=&quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi29-clang&quot;
export CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER=&quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android29-clang&quot;
export CARGO_TARGET_I686_LINUX_ANDROID_LINKER=&quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/i686-linux-android29-clang&quot;
export CARGO_TARGET_X86_64_LINUX_ANDROID_LINKER=&quot;/usr/local/lib/android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android29-clang&quot;
</code></pre>
<h2 id="setting-up-environment-variables-for-gdnative-sys"><a class="header" href="#setting-up-environment-variables-for-gdnative-sys">Setting up environment variables for <code>gdnative-sys</code></a></h2>
<p>The <code>gdnative-sys</code> crate can infer include paths for Android targets, but it requires the following environment variables:</p>
<ul>
<li><code>$ANDROID_SDK_ROOT</code>, which should point to the Android SDK root (which contains the <code>ndk</code> or <code>ndk-bundle</code> directory).</li>
<li><code>$ANDROID_NDK_VERSION</code>, which should contain the selected ndk version (if omitted, the latest version available is used and a warning is issued).</li>
</ul>
<p>Depending on your installation, these environment variables might have already been set. Otherwise, the variables may be set in bash:</p>
<pre><code class="language-bash">export ANDROID_SDK_ROOT=/path/to/android/sdk
export ANDROID_NDK_VERSION=21.4.7075529
</code></pre>
<p>... or in PowerShell on Windows:</p>
<pre><code class="language-powershell">$env:ANDROID_SDK_ROOT = &quot;C:\path\to\android\sdk&quot;
$env:ANDROID_NDK_VERSION = &quot;21.4.7075529&quot;
</code></pre>
<h2 id="building-the-gdnative-library"><a class="header" href="#building-the-gdnative-library">Building the GDNative library</a></h2>
<p>Finally, we can now build the GDNative library with Cargo for one or multiple targets:</p>
<pre><code class="language-bash">cargo build --release --target x86_64-linux-android
</code></pre>
<p><strong>Important note</strong>: ARM and x86 are, by design, different architectures. It is normal to get errors while running <code>cargo test</code> with a Rust library targeting ARMv7 on a x86-64 CPU, for example, since the CPU is unable to handle it.</p>
<h2 id="exporting-in-godot"><a class="header" href="#exporting-in-godot">Exporting in Godot</a></h2>
<h3 id="linking-to-android-binaries-in-gdns"><a class="header" href="#linking-to-android-binaries-in-gdns">Linking to Android binaries in <code>.gdns</code></a></h3>
<p>After building the GDNative libraries, we need to link them to Godot, by adding new entries in the GDNative library declaration file (<code>*.gdnlib</code>) for <code>Android.armeabi-v7a</code> (ARMv7),  <code>arm64-v8a</code> (ARM64), <code>Android.x86</code> (x86) and/or <code>Android.x86_64</code> (x86-64), depending of the toolchains we actually used in previous steps:</p>
<pre><code>[entry]

Android.armeabi-v7a=&quot;res://target/armv7-linux-androideabi/release/lib.so&quot;
Android.arm64-v8a=&quot;res://target/aarch64-linux-android/release/lib.so&quot;
Android.x86=&quot;res://target/i686-linux-android/release/lib.so&quot;
Android.x86_64=&quot;res://target/x86_64-linux-android/release/lib.so&quot;

[dependencies]

Android.armeabi-v7a=[  ]
Android.arm64-v8a=[  ]
Android.x86=[  ]
Android.x86_64=[  ]
</code></pre>
<h3 id="apk-signing-for-publication"><a class="header" href="#apk-signing-for-publication">APK signing for publication</a></h3>
<p>Usually, we can choose between releasing an app in <strong>Debug</strong> or <strong>Release</strong> mode. However, the Release mode is required when officially releasing to Play Store.</p>
<p>In order to configure Godot to sign Release APKs, we'll first need to generate a project-specific Release keystore using <code>keytool</code>, and set up an alias and a single password (as explained in the <a href="https://docs.godotengine.org/en/3.2/getting_started/workflow/export/exporting_for_android.html#exporting-for-google-play-store">Godot docs</a>, <code>-storepass</code> and <code>-keypass</code> option values must be the same):</p>
<pre><code class="language-bash">keytool -genkeypair -v -keystore path/to/my.keystore -alias some-alias -keyalg RSA -keysize 2048 -validity 10000 -storepass my-password -keypass my-password
</code></pre>
<p>Then, we will register its path in Export Settings (<em>Project &gt; Export</em>) or <code>export_presets.cfg</code>. Please note that passwords entered in the GUI will be stored in <code>export_presets.cfg</code>. Be sure to not commit it into any VCS!</p>
<pre><code># Remember to not commit the password as is in VCS!
keystore/release=&quot;path/to/my.keystore&quot;
keystore/release_user=&quot;some-alias&quot;
keystore/release_password=&quot;my-password&quot;
</code></pre>
<h3 id="exporting-2"><a class="header" href="#exporting-2">Exporting</a></h3>
<p>Finally, we can now export the project using the GUI (<em>Project &gt; Export... &gt; Android (Runnable)</em>) and uncheck &quot;<em>Export with Debug</em>&quot; in GUI when being asked to enter APK file name. We may also use one of the following commands from the CLI to do the same:</p>
<pre><code class="language-bash"># Debug mode
godot --export-debug &quot;Android&quot; path/to/my.apk

# Release mode
godot --export &quot;Android&quot; path/to/my.apk
</code></pre>
<p>When trying to install the app directly from the APK on an Android device, Play Protect may display a warning explaining that <em>the app developers are not recognized, so the app may be unsafe</em>. This is the expected behavior for an APK in Release mode that isn't actually released on Play Store.</p>
<p>If not planning to release on Play Store, one may file an appeal from Play Protect using <a href="https://support.google.com/googleplay/android-developer/contact/protectappeals">a form provided by Google</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios"><a class="header" href="#ios">iOS</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac-os-x"><a class="header" href="#mac-os-x">Mac OS X</a></h1>
<p><strong>Disclaimer</strong>: <em>Currently, the following steps are tested and confirmed to work on Linux only.</em></p>
<h2 id="use-case"><a class="header" href="#use-case">Use case</a></h2>
<p>Exporting for Mac OS X is interesting if:</p>
<ul>
<li>you do not have access to Apple hardware</li>
<li>you want to build from a CI, typically on a Docker image</li>
</ul>
<p>If you have access to a real Mac, building natively is easier.</p>
<h2 id="why-is-this-complex-"><a class="header" href="#why-is-this-complex-">Why is this complex ?</a></h2>
<p>Cross-compiling Rust programs for Mac OS X is as simple as:</p>
<pre><code class="language-sh">rustup target add x86_64-apple-darwin
cargo build --target x86_64-apple-darwin
</code></pre>
<p>However to build <a href="https://crates.io/crates/gdnative-sys">gdnative-sys</a> you
need a Mac OS X C/C++ compiler, the Rust compiler is not enough. More precisely you need
an SDK which usually comes with <a href="https://developer.apple.com/xcode/">Xcode</a>.
For Mac users, this SDK is &quot;just there&quot; but when cross-compiling, it is
typically missing, even if your compiler is able to produce Mac OS X compatible binaries.</p>
<p>The most common error is:</p>
<pre><code>fatal error: 'TargetConditionals.h' file not found
</code></pre>
<p>Installing just this file is not enough, this error is usually a consequence
of the whole SDK missing, so there is no chance you can get a build.</p>
<p>What you need to do is:</p>
<ul>
<li>download the SDK</li>
<li>fix all paths and other details so that it ressembles a Mac OS X environment</li>
<li>then build with <code>cargo build --target x86_64-apple-darwin</code></li>
</ul>
<p>Hopefully, the first two steps, downloading the SDK and fixing details,
are handled by a tool called <a href="https://github.com/tpoechtrager/osxcross">osxcross</a>
which is just about setting up a working C/C++ compiler on Linux.</p>
<h2 id="howto"><a class="header" href="#howto">Howto</a></h2>
<pre><code class="language-sh"># make sure you have a proper C/C++ native compiler first, as a suggestion:
sudo apt-get install llvm-dev libclang-dev clang libxml2-dev libz-dev

# change the following path to match your setup
export MACOSX_CROSS_COMPILER=$HOME/macosx-cross-compiler

install -d $MACOSX_CROSS_COMPILER/osxcross
install -d $MACOSX_CROSS_COMPILER/cross-compiler
cd $MACOSX_CROSS_COMPILER
git clone https://github.com/tpoechtrager/osxcross &amp;&amp; cd osxcross

# picked this version as they work well with godot-rust, feel free to change
git checkout 7c090bd8cd4ad28cf332f1d02267630d8f333c19
</code></pre>
<p>At this stage you need to <a href="https://github.com/tpoechtrager/osxcross#packaging-the-sdk">download and package the SDK</a>
which can not be distributed with osxcross for legal reasons.
<a href="https://www.apple.com/legal/sla/docs/xcode.pdf">Please ensure you have read and understood the Xcode license terms before continuing</a>.</p>
<p>You should now have an SDK file, for example <code>MacOSX10.10.sdk.tar.xz</code>.</p>
<pre><code class="language-sh"># move the file where osxcross expects it to be
mv MacOSX10.10.sdk.tar.xz $MACOSX_CROSS_COMPILER/osxcross/tarballs/
# build and install osxcross
UNATTENDED=yes OSX_VERSION_MIN=10.7 TARGET_DIR=$MACOSX_CROSS_COMPILER/cross-compiler ./build.sh
</code></pre>
<p>At this stage, you should have, in <code>$MACOSX_CROSS_COMPILER/cross-compiler</code>,
a working cross-compiler.</p>
<p>Now you need to tell Rust to use it when linking
Mac OS X programs:</p>
<pre><code class="language-sh">echo &quot;[target.x86_64-apple-darwin]&quot; &gt;&gt; $HOME/.cargo/config
find $MACOSX_CROSS_COMPILER -name x86_64-apple-darwin14-cc -printf 'linker = &quot;%p&quot;\n' &gt;&gt; $HOME/.cargo/config
echo &gt;&gt; $HOME/.cargo/config
</code></pre>
<p>After this, your <code>$HOME/.cargo/config</code> (not the <code>cargo.toml</code> file in your project, this is a different file)
should contain:</p>
<pre><code class="language-toml">[target.x86_64-apple-darwin]
linker = &quot;/home/my-user-name/macosx-cross-compiler/cross-compiler/bin/x86_64-apple-darwin14-cc&quot;
</code></pre>
<p>Then, we need to also tell the compiler to use the right compiler and headers.
In our example, with SDK 10.10, the env vars we need to export are:</p>
<pre><code class="language-sh">C_INCLUDE_PATH=$MACOSX_CROSS_COMPILER/cross-compiler/SDK/MacOSX10.10.sdk/usr/include
CC=$MACOSX_CROSS_COMPILER/cross-compiler/bin/x86_64-apple-darwin14-cc
</code></pre>
<p>You probably do not want to export those permanently as they are very
specific to building for Mac OS X so they are typically passed at each
call to <code>cargo</code>, eg:</p>
<pre><code class="language-sh">C_INCLUDE_PATH=$MACOSX_CROSS_COMPILER/cross-compiler/SDK/MacOSX10.10.sdk/usr/include CC=$MACOSX_CROSS_COMPILER/cross-compiler/bin/x86_64-apple-darwin14-cc cargo build --release --target x86_64-apple-darwin
</code></pre>
<p>As a consequence, you do <em>not</em> need to put <code>$MACOSX_CROSS_COMPILER/cross-compiler/bin</code> in your <code>$PATH</code> if
you only plan to export <a href="https://github.com/godot-rust/godot-rust">godot-rust</a> based programs, as the
binary needs to be explicitly overloaded.</p>
<h2 id="exporting-3"><a class="header" href="#exporting-3">Exporting</a></h2>
<p>Once your <code>.dylib</code> file is built, a standard Godot export should work:</p>
<pre><code class="language-sh">godot --export &quot;Mac OSX&quot; path/to/my.zip
</code></pre>
<p>Note that when exporting from a non Mac OS X platform, it is not possible to build a <code>.dmg</code>.
Instead, a <code>.zip</code> is produced. Again, the tool required to build Mac OS X disk images is
only available on Mac OS X. The <code>.zip</code> works fine though, it just contains <code>my.app</code>
folder, ready to use.</p>
<p>Double-check your <code>.dylib</code> file is there.</p>
<h2 id="useful-links"><a class="header" href="#useful-links">Useful links</a></h2>
<ul>
<li><a href="https://github.com/tpoechtrager/osxcross">https://github.com/tpoechtrager/osxcross</a>: tool used to install the Mac OS X SDK on Linux</li>
<li><a href="https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html">https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html</a>: a complete tutorial on how to use osxcross</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-guides"><a class="header" href="#advanced-guides">Advanced Guides</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-custom-builds-of-godot"><a class="header" href="#using-custom-builds-of-godot">Using custom builds of Godot</a></h1>
<p>As you probably know, godot-rust interacts with Godot via the GDNative interface. This interface is formally specified in a file called <code>api.json</code>, which lists all the classes, functions, constants and other symbols. In its build step, godot-rust reads this file and generates Rust code reflecting the GDNative interface.</p>
<p>By default, godot-rust ships an <code>api.json</code> compatible with the latest Godot 3.x release. This makes it easy to use the latest version. But there are cases where you might want to use an older Godot version, or one that you built yourself (with custom compiler flags or modules). In the past, this needed quite a few manual steps; in the meantime, this process has been simplified.</p>
<p>For using custom Godot builds, the first thing you need to do is to add the feature flag <code>custom-godot</code> when adding godot-rust as a dependency.
For example, if you depend on the latest GitHub version of godot-rust, Cargo.toml would look like this:</p>
<pre><code class="language-toml">gdnative = { git = &quot;https://github.com/godot-rust/godot-rust.git&quot;, features = [&quot;custom-godot&quot;] }
</code></pre>
<p>Next, godot-rust must be able to locate the Godot engine executable on your system.<br />
There are two options:</p>
<ol>
<li>Your executable is called <code>godot</code> and available in the system PATH.<br />
On Windows systems, this would also find a <code>godot.bat</code>, for example.</li>
<li>You define an environment variable <code>GODOT_BIN</code> with the absolute path to your executable.<br />
It is important that you include the filename -- this is not a directory path. </li>
</ol>
<p>That's it. During build, godot-rust will invoke Godot to generate a matching <code>api.json</code> -- you might see a short Godot window popping up.</p>
<p>Keep in mind that we only support Godot versions &gt;= 3.2 and &lt; 4.0 for now. Also, the GDNative API varies between versions, so you may need to adjust your client code. </p>
<h2 id="previous-approach"><a class="header" href="#previous-approach">Previous approach</a></h2>
<blockquote>
<p><em><strong>Note:</strong> this guide is now obsolete.</em><br />
<em>You can still use it when working with godot-rust 0.9 or <code>master</code> versions before December 2021.</em></p>
</blockquote>
<p>Sometimes, users might need to use a different version of the engine that is different from the default one, or is a custom build. In order to use <code>godot-rust</code> with them, one would need to create a custom version of the <code>gdnative-bindings</code> crate, generated from an <code>api.json</code> from the custom build. This guide walks through the necessary steps to do so.</p>
<p>First, obtain the source code for <code>gdnative-bindings</code> from crates.io. For this guide, we'll use <a href="https://github.com/Xion/cargo-download/"><code>cargo-download</code></a> to accomplish this:</p>
<pre><code># Install the `cargo-download` sub-command if it isn't installed yet
cargo install cargo-download

# Download and unpack the crate
cargo download gdnative-bindings==0.9.0 &gt;gdnative-bindings.tar.gz
tar -xf gdnative-bindings.tar.gz
</code></pre>
<p>You should be able to find the source code for the crate in a <code>gdnative-bindings-{version}</code> directory. Rename it to a distinctive name like <code>gdnative-bindings-custom</code> and update the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;gdnative-bindings-custom&quot;
</code></pre>
<p>When downloading the crate, please specify the exact version of the crate that is specified in the <code>Cargo.toml</code> of <code>gdnative</code>. This is necessary because the generated bindings depend on internal interfaces that may change between non-breaking versions of <code>gdnative</code>.</p>
<p>After source is obtained, replace the API description file with one generated by your specific Godot build:</p>
<pre><code>cd /path/to/gdnative-bindings-custom
/path/to/godot --gdnative-generate-json-api api.json

# Try to build and see if it works
cargo build
</code></pre>
<p>If everything goes well, you can now update the dependencies of your GDNative library to use this custom bindings crate:</p>
<pre><code class="language-toml">[dependencies]

# Use the exact version corresponding to `gdnative-bindings`
# and disable the default re-export.
gdnative = { version = &quot;=0.9.0&quot;, default-features = false, features = [] }

# Use your custom bindings crate as a path dependency
gdnative-bindings-custom = { path = &quot;/path/to/gdnative-bindings-custom&quot; }
</code></pre>
<p>Here, <code>gdnative</code> is specified using an exact version because the bindings generator is an internal dependency. When using custom binding crates, care must be taken to ensure that the version of the bindings crate used as the base matches the one specified in the <code>Cargo.toml</code> of the <code>gdnative</code> crate exactly, even for updates that are considered non-breaking in the <code>gdnative</code> crate. Using an exact version bound here helps prevent unintentional updates that may break the build.</p>
<p>Finally, replace references to <code>gdnative::api</code> with <code>gdnative-bindings-custom</code>. You should now be able to use the APIs in your custom build in Rust!</p>
<h2 id="generating-documentation"><a class="header" href="#generating-documentation">Generating documentation</a></h2>
<p>However, if you try to generate documentation with rustdoc at this point, you might notice that documentation might be missing or wrong for some of the types or methods. This is due to documentation being stored separately from the API description itself, and can be easily fixed if you have access to the source code from which your custom Godot binary is built.</p>
<p>To get updated documentation, you only need to copy all the documentation XMLs from <code>doc/classes</code> in the Godot source tree, to the <code>docs</code> directory in the <code>gdnative-bindings</code> source. After the files are copied, you should be able to get correct documentation for the API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-godot-rust-08-to-09x"><a class="header" href="#migrating-from-godot-rust-08-to-09x">Migrating from godot-rust 0.8 to 0.9.x</a></h1>
<p>In version 0.9, we are attempting to resolve many long-standing problems in the older API. As a result, there are many breaking changes in the public interface. This is a quick guide to the new API for users that have used older versions.</p>
<h2 id="module-organization-and-naming"><a class="header" href="#module-organization-and-naming">Module organization and naming</a></h2>
<h3 id="generated-api-types"><a class="header" href="#generated-api-types">Generated API types</a></h3>
<p>Generated types now live under the <code>gdnative::api</code> module. This makes the top-level namespace easier to navigate in docs. If you have used glob imports like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::*;
<span class="boring">}
</span></code></pre></pre>
<p>..., you should change this to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;
use gdnative::api::*;
<span class="boring">}
</span></code></pre></pre>
<h3 id="generated-property-accessors"><a class="header" href="#generated-property-accessors">Generated property accessors</a></h3>
<p>Generated getters of properties are no longer prefixed with <code>get_</code>. This <strong>does not</strong> affect other methods that start with <code>get_</code> that are not getters, like <code>File::get_8</code>.</p>
<h3 id="separation-of-core-types-and-nativescript-code"><a class="header" href="#separation-of-core-types-and-nativescript-code">Separation of core types and NativeScript code</a></h3>
<p>Core types, like <code>VariantArray</code>, <code>Color</code>, and <code>Dictionary</code> are moved to the <code>gdnative::core_types</code> module, while NativeScript supporting code like <code>NativeClass</code>, <code>Instance</code> and <code>init</code> code are moved to the <code>gdnative::nativescript</code> module. Most of the commonly-used types are re-exported in the <code>prelude</code>, but if you prefer individual imports, the paths need to be changed accordingly.</p>
<h3 id="api-enums"><a class="header" href="#api-enums">API enums</a></h3>
<p>C enums in the API are now generated in submodules of <code>gdnative_bindings</code> named after their associated objects. Common prefixes are also stripped from the constant names. The constants are accessed as associated constants:</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::*;

object.connect(
    &quot;foo&quot;.into(),
    owner.to_object(),
    &quot;_handle_foo&quot;.into(),
    VariantArray::new(),
    Object::CONNECT_DEFERRED,
);
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gdnative::prelude::*;
use gdnative::api::object::ConnectFlags;

object.connect(&quot;foo&quot;, owner, &quot;_handle_foo&quot;, VariantArray, ConnectFlags::DEFERRED.into());
<span class="boring">}
</span></code></pre></pre>
<h3 id="fixed-typos"><a class="header" href="#fixed-typos">Fixed typos</a></h3>
<p>Typos in variant names of <code>VariantOperator</code> and <code>GodotError</code> are fixed. Change to the correct names if this breaks your code.</p>
<h2 id="changes-to-derive-macros"><a class="header" href="#changes-to-derive-macros">Changes to derive macros</a></h2>
<p>The <code>NativeScript</code> derive macro now looks for <code>new</code> instead of <code>_init</code> as the constructor.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Object)]
pub struct Thing;

impl Thing {
    fn _init(_owner: Object) -&gt; Self {
        Thing
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Object)]
pub struct Thing;

impl Thing {
    // `owner` may also be `TRef&lt;Object&gt;`, like in exported methods.
    fn new(_owner: &amp;Object) -&gt; Self {
        Thing
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="argument-casts"><a class="header" href="#argument-casts">Argument casts</a></h2>
<p>Generated methods taking objects, <code>Variant</code>, and <code>GodotString</code> are now made generic using <code>impl Trait</code> in argument position. This make calls much less verbose, but may break inference for some existing code. If you have code that looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut binds = VariantArray::new();
binds.push(&amp;42.to_variant());
binds.push(&amp;&quot;foo&quot;.to_variant());
thing.connect(
    &quot;foo&quot;.into(),
    Some(owner.to_object()),
    &quot;bar&quot;.into(),
    binds,
    0,
)
<span class="boring">}
</span></code></pre></pre>
<p>..., you should change this to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut binds = VariantArray::new();
binds.push(42);
binds.push(&quot;foo&quot;);
thing.connect(&quot;foo&quot;, owner, &quot;bar&quot;, binds, 0);
<span class="boring">}
</span></code></pre></pre>
<h3 id="explicit-nulls"><a class="header" href="#explicit-nulls">Explicit nulls</a></h3>
<p>A side effect of accepting generic arguments is that inference became tricky for <code>Option</code>. As a solution for this, an explicit <code>Null</code> type is introduced for use as method arguments. To obtain a <code>Null</code> value, you may use either <code>GodotObject::null()</code> or <code>Null::null()</code>. You may also call <code>null</code> on specific types since it is a trait method for all API types, e.g. <code>Node::null()</code> or <code>Object::null()</code>.</p>
<p>For example, to clear the script on an object, instead of:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thing.set_script(None);
<span class="boring">}
</span></code></pre></pre>
<p>..., you should now write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thing.set_script(Null::null());
<span class="boring">}
</span></code></pre></pre>
<p>This is arguably less convenient, but passing explicit nulls should be rare enough a use case that the benefits of having polymorphic arguments are much more significant.</p>
<h2 id="object-semantics"><a class="header" href="#object-semantics">Object semantics</a></h2>
<p>In 0.9, the way Godot objects are represented in the API is largely remodeled to closely match the behavior of Godot. For the sake of illustration, we'll use the type <code>Node</code> in the following examples.</p>
<p>In 0.8.x, bare objects like <code>Node</code> are either unsafe or reference-counted pointers. Some of the methods require <code>&amp;mut</code> receivers, but there is no real guarantee of uniqueness since the pointers may be cloned or aliased freely. This restriction is not really useful for safety, and requires a lot of operations to be <code>unsafe</code>.</p>
<p>This is changed in 0.9 with the typestate pattern, which will be explained later. Now, there are three representations of Godot objects, with different semantics:</p>
<table><thead><tr><th>Type</th><th>Terminology</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>&amp;'a Node</code></td><td>bare reference</td><td>reference assumed or guaranteed to be valid and uncontended during <code>'a</code></td></tr>
<tr><td><code>Ref&lt;Node, Access&gt;</code></td><td>persistent reference</td><td>stored reference whose validity is not always known, depending on the typestate <code>Access</code></td></tr>
<tr><td><code>TRef&lt;'a, Node, Access&gt;</code></td><td>temporary reference</td><td>reference assumed or guaranteed to be valid and uncontended during <code>'a</code>, with added typestate tracking</td></tr>
</tbody></table>
<p>Note that owned bared objects, like <code>Node</code>, no longer exist in the new API. They should be replaced with <code>Ref</code> or <code>TRef</code> depending on the situation:</p>
<ul>
<li>In persistent data structures, like <code>NativeScript</code> structs, use <code>Ref&lt;Node, Access&gt;</code>.</li>
<li>When taking the <code>owner</code> argument, use <code>&amp;Node</code> or <code>TRef&lt;'a, Node, Shared&gt;</code>. The latter form allows for more safe operations, like using as method arguments, thanks to the typestate.</li>
<li>When taking objects from the engine, like as arguments other than <code>owner</code>, use <code>Ref&lt;Node, Shared&gt;</code>.</li>
<li>When passing objects to the engine as arguments or return values, use <code>&amp;Ref&lt;Node, Shared&gt;</code>, <code>Ref&lt;Node, Unique&gt;</code>, or <code>TRef&lt;'a, Node, Shared&gt;</code>.</li>
<li>When passing temporary references around in internal code, use <code>TRef&lt;'a, Node, Access&gt;</code>.</li>
</ul>
<p>All objects are also seen as having interior mutability in Rust parlance, which means that all API methods now take <code>&amp;self</code> instead of <code>&amp;mut self</code>. For more information about shared (immutable) and unique (mutable) references, see <a href="https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html">Accurate mental model for Rust's reference types</a> by dtolnay.</p>
<p>Unlike the previous versions requiring ubiquitous <code>unsafe</code>s, the new API allows for clearer separation of safe and unsafe code in Rust. In general, <code>unsafe</code> is only necessary around the border between Godot and Rust, while most of the internal code can now be safe.</p>
<p>To convert a <code>Ref</code> to a <code>TRef</code>, use <code>Ref::assume_safe</code> or <code>Ref::as_ref</code> depending on the object type and typestate. To convert non-unique <code>TRef</code>s to <code>Ref</code>s, use <code>TRef::claim</code>. Bare references are usually obtained through <code>Deref</code>, and it's not recommended to use them directly.</p>
<p>For detailed information about the API, see the type-level documentation on <code>Ref</code> and <code>TRef</code>.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>If you prefer to learn by examples, here is the simplified code for instancing child scenes in the dodge-the-creeps example in 0.8. Note how everything is <code>unsafe</code> due to <code>Node</code>s being manually-managed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
pub struct Main {
    #[property]
    mob: PackedScene,
}

#[methods]
impl Main {
    #[export]
    unsafe fn on_mob_timer_timeout(&amp;self, owner: Node) {
        let mob_scene: RigidBody2D = instance_scene(&amp;self.mob).unwrap();
        let direction = rng.gen_range(-PI / 4.0, PI / 4.0);
        mob_scene.set_rotation(direction);
        owner.add_child(Some(mob_scene.to_node()), false);
    }
}

unsafe fn instance_scene&lt;Root&gt;(scene: &amp;PackedScene) -&gt; Result&lt;Root, ManageErrs&gt;
where
    Root: gdnative::GodotObject,
{
    let inst_option = scene.instance(PackedScene::GEN_EDIT_STATE_DISABLED);

    if let Some(instance) = inst_option {
        if let Some(instance_root) = instance.cast::&lt;Root&gt;() {
            Ok(instance_root)
        } else {
            Err(ManageErrs::RootClassNotRigidBody2D(
                instance.name().to_string(),
            ))
        }
    } else {
        Err(ManageErrs::CouldNotMakeInstance)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this can now be written as (with added type annotations and explanations for clarity):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
pub struct Main {
    #[property]
    mob: Ref&lt;PackedScene, Shared&gt;,
}

#[methods]
impl Main {
    #[export]
    fn on_mob_timer_timeout(&amp;self, owner: &amp;Node) {
        // This assumes that the `PackedScene` cannot be mutated from
        // other threads during this method call. This is fine since we
        // know that no other scripts mutate the scene at runtime.
        let mob: TRef&lt;PackedScene, Shared&gt; = unsafe { self.mob.assume_safe() };

        // Call the internal function `instance_scene` using the `TRef`
        // produced by `assume_safe`. This is safe because we already
        // assumed the safety of the object.
        let mob_scene: Ref&lt;RigidBody2D, Unique&gt; = instance_scene(mob);

        // `mob_scene` can be used directly because it is a `Unique`
        // reference -- we just created it and there can be no other
        // references to it in the engine.
        let direction = rng.gen_range(-PI / 4.0, PI / 4.0);
        mob_scene.set_rotation(direction);

        // `mob_scene` can be passed safely to the `add_child` method
        // by value since it is a `Unique` reference.
        // Note that there is no need to cast the object or wrap it in an
        // `Option`.
        owner.add_child(mob_scene, false);

        // Note that access to `mob_scene` is lost after it's passed
        // to the engine. If you need to use it after doing that,
        // convert it into a `Shared` one with `into_shared().assume_safe()`
        // first.
    }
}

// The `instance_scene` function now expects `TRef` arguments, which expresses
// at the type level that this function expects a valid and uncontended
// reference during the call.
//
// Note that this makes the interface safe.
fn instance_scene&lt;Root&gt;(scene: TRef&lt;PackedScene, Shared&gt;) -&gt; Ref&lt;Root, Unique&gt;
where
    // More static guarantees are now available for `cast` using the `SubClass`
    // trait. This ensures that you can only downcast to possible targets.
    Root: gdnative::GodotObject&lt;RefKind = ManuallyManaged&gt; + SubClass&lt;Node&gt;,
{
    // Instancing the scene is safe since `scene` is assumed to be safe.
    let instance = scene
        .instance(PackedScene::GEN_EDIT_STATE_DISABLED)
        .expect(&quot;should be able to instance scene&quot;);

    // `PackedScene::instance` is a generated API, so it returns
    // `Ref&lt;_, Shared&gt;` by default. However, we know that it actually creates
    // a new `Node` for us, so we can convert it to a `Unique` reference using
    // the `unsafe` `assume_unique` method.
    let instance = unsafe { instance.assume_unique() };

    // Casting to the `Root` type is also safe now.
    instance
        .try_cast::&lt;Root&gt;()
        .expect(&quot;root node type should be correct&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="casting"><a class="header" href="#casting">Casting</a></h2>
<p>The casting API is made more convenient with 0.9, using the <code>SubClass</code> trait. Casting is now covered by two generic methods implemented on all object reference types: <code>cast</code> and <code>upcast</code>. Both methods enforce cast validity statically, which means that the compiler will complain about casts that will always fail at runtime. The generated <code>to_*</code> methods are removed in favor of <code>upcast</code>.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="casting-a-node-to-object"><a class="header" href="#casting-a-node-to-object">Casting a <code>Node</code> to <code>Object</code></a></h4>
<p>In 0.8, you would write either of:</p>
<ul>
<li><code>node.to_object()</code></li>
<li><code>node.cast::&lt;Object&gt;().unwrap()</code></li>
</ul>
<p>In 0.9, this should now be written as <code>node.upcast::&lt;Object&gt;()</code>. This is a no-op at runtime because <code>Node</code> is a subclass of <code>Object</code>.</p>
<h4 id="casting-an-object-to-node"><a class="header" href="#casting-an-object-to-node">Casting an <code>Object</code> to <code>Node</code></a></h4>
<p>The API for downcasting to concrete types is unchanged. You should still write <code>object.cast::&lt;Node&gt;().unwrap()</code>.</p>
<h4 id="casting-to-a-type-parameter"><a class="header" href="#casting-to-a-type-parameter">Casting to a type parameter</a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn polymorphic_cast&lt;T: GodotObject&gt;(obj: Object) -&gt; Option&lt;T&gt; {
    obj.cast()
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, casting to a type parameter is a bit more complicated due to the addition of static checks. You should now write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn polymorphic_cast&lt;T, Access&gt;(
    obj: TRef&lt;Object, Access&gt;,
) -&gt; Option&lt;TRef&lt;T, Access&gt;&gt;
where
    T: GodotObject + SubClass&lt;Object&gt;,
    Access: ThreadAccess,
{
    obj.cast()
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that this function is also polymorphic over the <code>Access</code> typestate, which is explained the the following section.</p>
<h2 id="typestates"><a class="header" href="#typestates">Typestates</a></h2>
<p>The typestate pattern is introduced in 0.9 to statically provide fine-grained reference safety guarantees depending on thread access state. There are three typestates in the API:</p>
<ul>
<li><code>Shared</code>, for references that may be shared between multiple threads. <code>Shared</code> references are <code>Send</code> and <code>Sync</code>.</li>
<li><code>ThreadLocal</code>, for references that may only be shared on the current thread. <code>ThreadLocal</code> references are <code>!Send</code> and <code>!Sync</code>. This is because sending a <code>ThreadLocal</code> reference to another thread violates the invariant.</li>
<li><code>Unique</code>, for references that are <strong>globally unique</strong> (with the exception of specific engine internals like <code>ObjectDB</code>). <code>Unique</code> references are <code>Send</code> but <code>!Sync</code>. These references are always safe to use.</li>
</ul>
<p>Users may convert between typestates using the <code>into_*</code> and <code>assume_*</code> methods found on various types that deal with objects or <code>Variant</code> collections with interior mutability (<code>Dictionary</code> and <code>VariantArray</code>). Doing so has no runtime cost. The documentation should be referred to when calling the unsafe <code>assume_*</code> methods to avoid undefined behavior.</p>
<p>Typestates are encoded in types as the <code>Access</code> type parameter, like the ones in <code>Ref&lt;T, Access&gt;</code> and <code>Dictionary&lt;Access&gt;</code>. These type parameters default to <code>Shared</code>.</p>
<p>The general guidelines for using typestates are as follows:</p>
<ul>
<li>References obtained from the engine are <code>Shared</code> by default. This includes unique objects returned by generated API methods, because there isn't enough information to tell them from others.</li>
<li>Constructors return <code>Unique</code> references.</li>
<li><code>ThreadLocal</code> references are never returned directly. They can be created manually from other references, and can be used Godot objects and collections internally kept in Rust objects.</li>
</ul>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<h4 id="creating-a-dictionary-and-returning-it"><a class="header" href="#creating-a-dictionary-and-returning-it">Creating a <code>Dictionary</code> and returning it</a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn dict(&amp;self, _owner: Reference) -&gt; Dictionary {
    let mut dict = Dictionary::new();
    dict.insert(&amp;&quot;foo&quot;.into(), &amp;42.into());
    dict.insert(&amp;&quot;bar&quot;.into(), &amp;1337.into());
    dict
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as (with added type annotations and explanations for clarity):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
fn dict(&amp;self, _owner: &amp;Reference) -&gt; Dictionary&lt;Unique&gt; {
    // `mut` is no longer needed since Dictionary has interior mutability in
    // Rust parlance
    let dict: Dictionary&lt;Unique&gt; = Dictionary::new();

    // It is safe to insert into the `dict` because it is unique. Also note how
    // the conversion boilerplate is no longer needed for `insert`.
    dict.insert(&quot;foo&quot;, 42);
    dict.insert(&quot;bar&quot;, 1337);

    // Owned `Unique` references can be returned directly
    dict
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="using-an-object-argument-other-than-owner"><a class="header" href="#using-an-object-argument-other-than-owner">Using an object argument other than <code>owner</code></a></h4>
<p>In 0.8, you would write this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
unsafe fn connect_to(&amp;self, owner: Node, target: Object) {
    target.connect(
        &quot;foo&quot;.into(),
        owner.to_object(),
        &quot;_handle_foo&quot;.into(),
        VariantArray::new(),
        0,
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.9, this should now be written as (with added type annotations and explanations for clarity):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export]
// The `Access` parameter defaults to `Shared` for `Ref`, so it can be omitted
// in method signatures.
// Here, we also need to use `TRef` as the owner type, because we need the
// typestate information to pass it into `connect`.
fn connect_to(&amp;self, owner: TRef&lt;Node&gt;, target: Ref&lt;Object&gt;) {
    // Assume that `target` is safe to use for the body of this method.
    let target = unsafe { target.assume_safe() };
    // `TRef` references can be passed directly into methods without the need
    // for casts.
    target.connect(&quot;foo&quot;, owner, &quot;_handle_foo&quot;, VariantArray::new(), 0);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-godot-rust-09x-to-010x"><a class="header" href="#migrating-from-godot-rust-09x-to-010x">Migrating from godot-rust 0.9.x to 0.10.x</a></h1>
<p>Version 0.10 implements many improvements to ergonomics, naming consistency and bugfixes. Tooling and CI has been majorly overhauled, providing fast 
feedback cycles, higher confidence and easier-to-read documentation.</p>
<p>This guide outlines what actions users of godot-rust need to take to update their code.</p>
<h2 id="minimum-supported-rust-version"><a class="header" href="#minimum-supported-rust-version">Minimum supported Rust version</a></h2>
<p>The MSRV has been increased to 1.56. When migrating, you will need to ensure that you are using <strong>at least</strong> Rust 1.56 or later or your projects may fail to build.</p>
<p>We use the Rust 2021 edition; in your own code you may use any edition.</p>
<h2 id="breaking-api-changes"><a class="header" href="#breaking-api-changes">Breaking API changes</a></h2>
<p>This is a brief overview of the smaller breaking changes in the library API. Please refer to the <a href="https://github.com/godot-rust/godot-rust/blob/master/CHANGELOG.md">changelog</a> for a comprehensive list. </p>
<p>More sophisticated breaking changes are explained further down in section <a href="advanced-guides/migrating-0-9.html#Migrations"><em>Migrations</em></a>.</p>
<h3 id="changes-to-modules"><a class="header" href="#changes-to-modules">Changes to modules</a></h3>
<p>The module structure has been simplified to ensure there is only one module per symbol:</p>
<ul>
<li>Module <code>nativescript</code> has been renamed to <code>export</code>.</li>
<li>Types <code>nativescript::{Instance, RefInstance}</code> have been moved to <code>object</code>.</li>
<li>Less often used macros <code>godot_gdnative_init</code>, <code>godot_gdnative_terminate</code>, <code>godot_nativescript_init</code>, <code>godot_site</code> have been removed from the prelude.</li>
<li>Unnecessarily nested modules have also been removed. If you were depending upon the exact path, you will need to use the new path.</li>
</ul>
<h3 id="changes-to-core-types"><a class="header" href="#changes-to-core-types">Changes to core types</a></h3>
<ul>
<li>
<p>The euclid vector library has been removed and replaced with <a href="https://docs.rs/glam/latest/glam/">glam</a>.</p>
</li>
<li>
<p><code>Variant</code> has a redesigned conversion API.</p>
</li>
<li>
<p>Matrix types -- <code>Transform2D</code>, <code>Transform</code> and <code>Basis</code> -- have had their basis vectors renamed from <code>x/y/z</code> to <code>a/b/c</code>, to avoid confusion with the <code>x/y/z</code> vector components.</p>
</li>
<li>
<p>The following deprecated symbols have been removed:</p>
<ul>
<li><code>Reference::init_ref</code>(unsound)</li>
<li><code>ClassBuilder::add_method</code>, <code>add_method_advanced</code>, <code>add_method_with_rpc_mode</code></li>
<li><code>ScriptMethod</code></li>
<li><code>ScriptMethodFn</code> </li>
<li><code>ScriptMethodAttributes</code></li>
</ul>
</li>
<li>
<p>The following methods were removed due to being redundant:</p>
<ul>
<li>unsafe access methods for <code>VariantArray&lt;Shared&gt;</code> (available in <code>VariantArray&lt;Unique&gt;</code>)</li>
<li><code>Basis::invert</code></li>
<li><code>Basis::orthonormalize</code></li>
<li><code>Basis::rotate</code></li>
<li><code>Basis::tdotx</code></li>
<li><code>Basis::tdoty</code></li>
<li><code>Basis::tdotz</code></li>
<li><code>Rid::operator_less</code></li>
<li><code>StringName::operator_less</code></li>
</ul>
</li>
</ul>
<p>Various type names have been changed to improve clarity and consistency:</p>
<table><thead><tr><th>Old Type Name</th><th>New Type Name</th></tr></thead><tbody>
<tr><td><code>RefInstance</code></td><td><code>TInstance</code></td></tr>
<tr><td><code>RefKind</code></td><td><code>Memory</code></td></tr>
<tr><td><code>ThreadAccess</code></td><td><code>Ownership</code></td></tr>
<tr><td><code>TypedArray</code></td><td><code>PoolArray</code></td></tr>
<tr><td><code>Element</code></td><td><code>PoolElement</code></td></tr>
<tr><td><code>SignalArgument</code></td><td><code>SignalParam</code></td></tr>
<tr><td><code>Point2</code></td><td><code>Vector2</code></td></tr>
<tr><td><code>Size2</code></td><td><code>Vector2</code></td></tr>
</tbody></table>
<p>The following methods have been renamed:</p>
<table><thead><tr><th>Old Method</th><th>New Method</th></tr></thead><tbody>
<tr><td><code>{String,Variant}::forget</code></td><td><code>leak</code></td></tr>
<tr><td><code>Color::{rgb,rgba}</code></td><td><code>{from_rgb,from_rgba}</code></td></tr>
<tr><td><code>Rid::is_valid</code></td><td><code>is_occupied</code></td></tr>
<tr><td><code>Basis::to_scale</code></td><td><code>scale</code></td></tr>
<tr><td><code>Basis::from_elements</code></td><td><code>from_rows</code></td></tr>
<tr><td><code>Transform2D::from_axis_origin</code></td><td><code>from_basis_origin</code></td></tr>
<tr><td><code>StringName::get_name</code></td><td><code>to_godot_string</code></td></tr>
</tbody></table>
<h3 id="changes-to-procedural-macros"><a class="header" href="#changes-to-procedural-macros">Changes to procedural macros</a></h3>
<ul>
<li><code>#[inherit]</code> is now optional and defaults to <code>Reference</code> instead of <code>Node</code>.</li>
<li><code>#[property(before_set)]</code> and its siblings are replaced with <code>#[property(set)]</code> etc.; see below. </li>
</ul>
<h3 id="ownership-changes"><a class="header" href="#ownership-changes">Ownership Changes</a></h3>
<ul>
<li><code>Instance</code> and <code>TInstance</code> now use <code>Own=Shared</code> by default. Some adjustments to your assumptions should be re-evaluated as needed.</li>
</ul>
<h2 id="new-features"><a class="header" href="#new-features">New features</a></h2>
<p>In addition to new functionality outlined here, it can be interesting to check the <em>Added</em> section in the changelog.</p>
<h3 id="cargo-features"><a class="header" href="#cargo-features">Cargo features</a></h3>
<p>While these are not breaking changes, the following may be useful to consider when migrating, particularly if you were previously using a custom solution for either of the following:</p>
<ul>
<li><a href="https://serde.rs/">serde</a> is now supported for <code>VariantDispatch</code> and types in the <code>core_types</code> module.</li>
<li>Async Foundations have been completed, so you can now make use of Rust <code>async</code> runtimes with Godot more easily. We have a recipe for using <a href="advanced-guides/../recipes/async-tokio.html">async with the tokio runtime</a>.</li>
<li>Custom Godot builds are now supported. The advanced guide for <a href="advanced-guides/./custom-godot.html">Custom Godot</a> has been updated accordingly.</li>
</ul>
<h3 id="custom-property-exports"><a class="header" href="#custom-property-exports">Custom property exports</a></h3>
<p>In godot-rust 0.9, it was necessary to manually register properties using the class builder such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Reference)]
struct Foo {
    #[property]
    bar: i64,
}

#[methods] 
impl Foo {
  fn register_properties(builder: &amp;ClassBuilder&lt;Foo&gt;) {
    builder
        .add_property::&lt;String&gt;(&quot;bar&quot;)
        .with_getter(get_bar)
        .with_setter(set_bar)
        .with_default(0)
        .done();
  }
  #[export]
  fn set_bar(&amp;mut self, _owner: &amp;Reference, value: i64) {
      self.bar = value;
  }

  #[export]
  fn get_bar(&amp;mut self, _owner: &amp;Reference) -&gt; i64 {
      self.bar
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.10, this can be automated with the <code>#[property]</code> procedural macro, such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Reference)]
struct Foo {
    #[property(name = &quot;bar&quot;, set = &quot;set_bar&quot;, get = &quot;get_bar&quot;, default = 0)]
    bar: i64,
}

#[methods] 
impl Foo {
    #[export]
    fn set_bar(&amp;mut self, _owner: &amp;Reference, value: i64) {
        self.bar = value;
    }

    #[export]
    fn get_bar(&amp;mut self, _owner: &amp;Reference) -&gt; i64 {
        self.bar
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="variantdispatch"><a class="header" href="#variantdispatch"><code>VariantDispatch</code></a></h3>
<p><code>VariantDispatch</code> is an newly introduced type in godot-rust 0.10. This enum lets you treat <code>Variant</code> in a more rust-idiomatic way, e.g. by pattern-matching its contents:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let variant = 42.to_variant();

let number_as_float = match variant.dispatch() {
    VariantDispatch::I64(i) =&gt; i as f64,
    VariantDispatch::F64(f) =&gt; f,
    _ =&gt; panic!(&quot;not a number&quot;),
};

approx::assert_relative_eq!(42.0, number_as_float);
<span class="boring">}
</span></code></pre></pre>
<h2 id="migrations"><a class="header" href="#migrations">Migrations</a></h2>
<p>This section elaborates on APIs with non-trivial changes and guides you through the process of updating your code.</p>
<h3 id="variant-1"><a class="header" href="#variant-1"><code>Variant</code></a></h3>
<p>If you were using the <code>Variant::from_*</code> methods, those no longer exist.</p>
<p>In 0.9.x you would need to use the specific constructor, such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let variant = Variant::from_i64(42);
let variant = Variant::from_f64(42.0);
let variant2 = Variant::from_object(object);
<span class="boring">}
</span></code></pre></pre>
<p>In 0.10.x, <code>new()</code> is sufficient for any type that implements <code>ToVariant</code>, such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let variant = Variant::new(42);
let variant = Variant::new(42.0);
let variant2 = Variant::new(object);
<span class="boring">}
</span></code></pre></pre>
<p>When converting from a variant to a Rust type, it previously was necessary to do the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer64 = i64::from_variant(&amp;variant_i64).unwrap();
let float64 = f64::from_variant(&amp;variant_f64).unwrap();
let object = ObjectType::from_variant(&amp;variant_object).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>In 0.10.x, you can now cast your variants by using the <code>to()</code> function on <code>FromVariant</code>-enabled types, such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Note: If the compiler can infer your type, the turbofish `::&lt;T&gt;` is optional
let integer64 = variant.to::&lt;i64&gt;().unwrap();
let float64 = variant.to::&lt;f64&gt;().unwrap();
let object = variant.to_object::&lt;ObjectType&gt;().unwrap(); // returns Ref&lt;ObjectType&gt;
<span class="boring">}
</span></code></pre></pre>
<h3 id="transforms"><a class="header" href="#transforms">Transforms</a></h3>
<p>Previously, transforms were defined by the matrix identities such as <code>m11</code>, <code>m12</code>; now, they are referred by the vector name for consistency.</p>
<p>For example: When creating an identity <code>Transform2D</code> in 0.9.x, you would create it using the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tform = Transform2D::new(1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
<span class="boring">}
</span></code></pre></pre>
<p>In 0.10.x you now need to create it using <code>from_basis_origin</code> and use <code>a</code>, <code>b</code>, and <code>origin</code> vectors, such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tform = Transform2D::from_basis_origin(
    Vector2::new(1.0, 0.0),
    Vector2::new(0.0, 1.0),
    Vector2::new(1.0, 1.0),
);
<span class="boring">}
</span></code></pre></pre>
<h3 id="vector-types"><a class="header" href="#vector-types">Vector types</a></h3>
<p>The underlying vector library as well as the implementation have been fundamentally replaced. In 0.9.x, many of the goemetric types were thinly wrapping a separate library. This led to several wrapping classes such as <code>Point2</code>, <code>Size2</code> being removed now. In addition, other geometric types -- for example <code>Rect2</code>, <code>Quat</code>, <code>Transform</code>, <code>Plane</code> -- have all been changed, and certain convenience functions may not be available anymore, depending upon the struct.</p>
<p>For example: <code>Rect2</code> no longer has <code>width()</code> or <code>height()</code>, but lets you directly access its <code>size.x</code> or <code>size.y</code> fields.</p>
<h3 id="classbuilder"><a class="header" href="#classbuilder"><code>ClassBuilder</code></a></h3>
<p>The <a href="https://docs.rs/gdnative/latest/gdnative/prelude/struct.ClassBuilder.html"><code>ClassBuilder</code></a> type has been extended to use the builder pattern when registering signals and properties.</p>
<p>In 0.9, registering a signal would look like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn register_signals(builder: &amp;ClassBuilder&lt;Self&gt;) {
  builder.add_signal(
    Signal {
      name: &quot;signal1&quot;,
      args: &amp;[],
    }
  );
  builder.add_signal(
    Signal {
      name: &quot;signal2&quot;,
      args: &amp;[SignalArgument {
          name: &quot;myArg&quot;,
          default: 42.0.to_variant(),
          export_info: ExportInfo::new(VariantType::F64),
          usage: PropertyUsage::DEFAULT,
      }],
  });
}
<span class="boring">}
</span></code></pre></pre>
<p>In 0.10, this changes to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn register_signals(builder: &amp;ClassBuilder&lt;Self&gt;) {
  builder.signal(&quot;signal1&quot;).done();
  
  builder.signal(&quot;signal2&quot;)
    .with_param_custom(
      SignalParam {
          name: &quot;myArg&quot;,
          default: 42.0.to_variant(),
          export_info: ExportInfo::new(VariantType::F64),
          usage: PropertyUsage::DEFAULT,
      },
    ).done();

  // If you only need a default value, you can also register a signal like this:
  builder.signal(&quot;signal3&quot;)
    .with_param_default(&quot;myArg&quot;, 42.0.to_variant())
    .done()
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="server-singletons"><a class="header" href="#server-singletons">Server singletons</a></h3>
<p>Godot's server singletons have received a safety overhaul. As a result, all functions that take one or more parameters of type <code>Rid</code> are now marked <code>unsafe</code> and thus require being used inside an <code>unsafe</code> block or <code>unsafe</code> function.</p>
<p>In 0.9.x, creating a canvas_item and attaching it to a parent would be done as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vs = unsafe { VisualServer::godot_singleton() };
let canvas = vs.canvas_create();
let ci = vs.canvas_item_create();
vs.canvas_item_set_parent(ci, canvas);
<span class="boring">}
</span></code></pre></pre>
<p>In 0.10.x, you now must wrap the <code>canvas_item_set_parent</code> function in an <code>unsafe</code> block, such as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vs = unsafe { VisualServer::godot_singleton() };
let canvas = vs.canvas_create();
let ci = vs.canvas_item_create();
unsafe {
  vs.canvas_item_set_parent(ci, canvas);
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="additional-ub-notes"><a class="header" href="#additional-ub-notes">Additional UB notes</a></h4>
<p>The reason for this change was due to <a href="https://github.com/godot-rust/godot-rust/issues/836">issue #836</a> being raised. Developers were able to demonstrate that you could easily cause undefined behavior when using any function that accepted <code>Rid</code> as a parameter, such as the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vs = unsafe { VisualServer::godot_singleton() };
let canvas = vs.canvas_create();
let vp = vs.viewport_create();
vs.canvas_item_set_parent(vp, canvas); // crashes immediately
vs.canvas_item_set_parent(canvas, canvas); // crashes at shutdown
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
