<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Common code questions - The godot-rust Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../getting-started/hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello, world!</a></li></ol></li><li class="chapter-item expanded "><a href="../gdnative-overview.html"><strong aria-hidden="true">3.</strong> An Overview of GDNative</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gdnative-overview/data-representations.html"><strong aria-hidden="true">3.1.</strong> Data representations</a></li><li class="chapter-item expanded "><a href="../gdnative-overview/wrappers.html"><strong aria-hidden="true">3.2.</strong> Ref, TRef and Instance</a></li><li class="chapter-item expanded "><a href="../gdnative-overview/architecture.html"><strong aria-hidden="true">3.3.</strong> Game architecture</a></li></ol></li><li class="chapter-item expanded "><a href="../rust-binding.html"><strong aria-hidden="true">4.</strong> Binding to Rust code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust-binding/classes.html"><strong aria-hidden="true">4.1.</strong> Class registration</a></li><li class="chapter-item expanded "><a href="../rust-binding/methods.html"><strong aria-hidden="true">4.2.</strong> Exported methods</a></li><li class="chapter-item expanded "><a href="../rust-binding/properties.html"><strong aria-hidden="true">4.3.</strong> Exported properties</a></li><li class="chapter-item expanded "><a href="../rust-binding/to-variant-from-variant-export.html"><strong aria-hidden="true">4.4.</strong> ToVariant, FromVariant and Export</a></li><li class="chapter-item expanded "><a href="../rust-binding/calling-gdscript.html"><strong aria-hidden="true">4.5.</strong> Calling into GDScript from Rust</a></li></ol></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../faq/code.html" class="active"><strong aria-hidden="true">5.1.</strong> Common code questions</a></li><li class="chapter-item expanded "><a href="../faq/multithreading.html"><strong aria-hidden="true">5.2.</strong> Multithreading</a></li><li class="chapter-item expanded "><a href="../faq/configuration.html"><strong aria-hidden="true">5.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../faq/support.html"><strong aria-hidden="true">5.4.</strong> Versioning and supported platforms</a></li><li class="chapter-item expanded "><a href="../faq/community.html"><strong aria-hidden="true">5.5.</strong> Community</a></li><li class="chapter-item expanded "><a href="../faq/godot4.html"><strong aria-hidden="true">5.6.</strong> Godot 4.0 Status</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">6.</strong> (TODO) Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/structure.html"><strong aria-hidden="true">6.1.</strong> Structuring code for testing</a></li><li class="chapter-item expanded "><a href="../testing/engine.html"><strong aria-hidden="true">6.2.</strong> Testing with the engine</a></li></ol></li><li class="chapter-item expanded "><a href="../recipes.html"><strong aria-hidden="true">7.</strong> Recipes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../recipes/async-tokio.html"><strong aria-hidden="true">7.1.</strong> Async with Tokio runtime</a></li><li class="chapter-item expanded "><a href="../recipes/custom-node-plugin.html"><strong aria-hidden="true">7.2.</strong> Custom node plugin</a></li><li class="chapter-item expanded "><a href="../recipes/external-resources.html"><strong aria-hidden="true">7.3.</strong> Loading external resources</a></li><li class="chapter-item expanded "><a href="../recipes/logging.html"><strong aria-hidden="true">7.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="../recipes/nix-build-system.html"><strong aria-hidden="true">7.5.</strong> Nix as development environment</a></li><li class="chapter-item expanded "><a href="../recipes/panic-handler.html"><strong aria-hidden="true">7.6.</strong> Rust panic handler</a></li></ol></li><li class="chapter-item expanded "><a href="../projects.html"><strong aria-hidden="true">8.</strong> Third-party projects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../projects/games.html"><strong aria-hidden="true">8.1.</strong> Games</a></li><li class="chapter-item expanded "><a href="../projects/tools.html"><strong aria-hidden="true">8.2.</strong> Tools and integrations</a></li><li class="chapter-item expanded "><a href="../projects/applications.html"><strong aria-hidden="true">8.3.</strong> Applications</a></li></ol></li><li class="chapter-item expanded "><a href="../exporting.html"><strong aria-hidden="true">9.</strong> Exporting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../exporting/android.html"><strong aria-hidden="true">9.1.</strong> Android</a></li><li class="chapter-item expanded "><a href="../exporting/ios.html"><strong aria-hidden="true">9.2.</strong> (TODO) iOS</a></li><li class="chapter-item expanded "><a href="../exporting/macosx.html"><strong aria-hidden="true">9.3.</strong> Mac OS X</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced-guides.html"><strong aria-hidden="true">10.</strong> Advanced Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced-guides/custom-godot.html"><strong aria-hidden="true">10.1.</strong> Using custom Godot versions</a></li><li class="chapter-item expanded "><a href="../advanced-guides/migrating-0-8.html"><strong aria-hidden="true">10.2.</strong> Migrating from godot-rust 0.8</a></li><li class="chapter-item expanded "><a href="../advanced-guides/migrating-0-9.html"><strong aria-hidden="true">10.3.</strong> Migrating from godot-rust 0.9</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The godot-rust Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="faq-common-code-questions"><a class="header" href="#faq-common-code-questions">FAQ: Common code questions</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="#how-do-i-store-a-reference-of-node">How do I store a reference of <code>Node</code>?</a></li>
<li><a href="#borrow-failed-a-mut-reference-was-requested">Borrow failed; a &amp;mut reference was requested</a></li>
<li><a href="#why-do-mutating-godot-methods-take-self-and-not-mut-self">Why do mutating Godot methods take <code>&amp;self</code> and not <code>&amp;mut self</code>?</a></li>
<li><a href="#why-is-there-so-much-unsafe-in-godot-rust">Why is there so much <code>unsafe</code> in godot-rust?</a></li>
<li><a href="#can-the-new-constructor-have-additional-parameters">Can the <code>new</code> constructor have additional parameters?</a></li>
<li><a href="#can-i-implement-static-methods-in-gdnative">Can I implement static methods in GDNative?</a></li>
<li><a href="#how-do-i-convert-from-a-variant-to-the-underlying-rust-type">How do I convert from a <code>Variant</code> to the underlying Rust type?</a></li>
<li><a href="#is-it-possible-to-set-subproperties-of-a-godot-type-such-as-a-material">Is it possible to set subproperties of a Godot type, such as a <code>Material</code>?</a></li>
<li><a href="#what-is-the-rust-equivalent-of-preload">What is the Rust equivalent of <code>preload</code>?</a></li>
<li><a href="#how-can-function-parameters-accept-godot-subclasses-polymorphism">How can function parameters accept Godot subclasses (polymorphism)?</a></li>
<li><a href="#what-is-the-rust-equivalent-of-onready-var">What is the Rust equivalent of <code>onready var</code>?</a></li>
<li><a href="#what-types-are-supported-for-passing-through-the-gdnative-api">What types are supported for passing through the GDNative API?</a></li>
<li><a href="#how-can-i-profile-my-code-to-measure-performance">How can I profile my code to measure performance?</a></li>
</ul>
<h2 id="how-do-i-store-a-reference-of-node"><a class="header" href="#how-do-i-store-a-reference-of-node">How do I store a reference of <code>Node</code>?</a></h2>
<p>The idiomatic way to maintain a reference to a node in the SceneTree from Rust is to use <code>Option&lt;Ref&lt;T&gt;&gt;</code>.</p>
<p>For example, the following GDScript code:</p>
<pre><code class="language-gdscript">extends Node
class_name MyClass
var node

func _ready():
  node = Node.new()
  self.add_child(node, false)

</code></pre>
<p>could be translated to this Rust snippet:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
#[no_constructor]
struct MyNode {
    node_ref: Option&lt;Ref&lt;Node&gt;&gt;
}

#[methods]
impl MyNode {
    #[export]
    fn _ready(&amp;self, owner: TRef&lt;Node&gt;) {
        let node = Node::new();
        owner.add_child(node);
        self.node_ref = Some(node.claim());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note: As <code>TRef&lt;T&gt;</code> is a temporary pointer, it will be necessary to get the base pointer <code>Ref&lt;T&gt;</code> in order to continue to hold this value.</p>
<p>This can be done with the <a href="https://docs.rs/gdnative/latest/gdnative/struct.TRef.html#method.claim"><code>TRef&lt;T&gt;::claim()</code></a> function that returns the persistent version of the pointer, which you can store in your class.</p>
<h2 id="borrow-failed-a-mut-reference-was-requested"><a class="header" href="#borrow-failed-a-mut-reference-was-requested">Borrow failed; a &amp;mut reference was requested</a></h2>
<p>In Rust, <a href="https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html">there can only be <em>one</em> <code>&amp;mut</code> reference to the same memory location at the same time</a>. To enforce this while making simple use cases easier, the bindings make use of <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>. This works like a lock: whenever a method with <code>&amp;mut self</code> is called, it will try to obtain a lock on the <code>self</code> value, and hold it <em>until it returns</em>. As a result, if another method that takes <code>&amp;mut self</code> is called in the meantime for whatever reason (e.g. signals), the lock will fail and an error (<code>BorrowFailed</code>) will be produced.</p>
<p>It's relatively easy to work around this problem, though: Because of how the user-data container works, it can only see the outermost layer of your script type - the entire structure. This is why it's stricter than what is actually required. If you run into this problem, you can <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">introduce finer-grained interior mutability</a> in your own type, and modify the problematic exported methods to take <code>&amp;self</code> instead of <code>&amp;mut self</code>.</p>
<p>This issue also can often occur when using signals to indicate an update such as in the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
// register_with attribute can be used to specify custom register function for node signals and properties
#[register_with(Self::register_signals)]
struct SignalEmitter {
    data: LargeData,
}

#[methods]
impl SignalEmitter {
    fn register_signals(builder: &amp;ClassBuilder&lt;Self&gt;) {
        builder.add_signal(Signal { name: &quot;updated&quot;, args: &amp;[] });
    }

    fn new(_owner: &amp;Node) -&gt; Self {
        SignalEmitter {
            data: &quot;initial&quot;,
        }
    }
    #[export]
    fn update_data(&amp;mut self, owner: TRef&lt;Node&gt;, data: LargeData) {
        self.data = data;
        owner.emit_signal(&quot;updated&quot;, &amp;[]);
    }
    #[export]
    fn get_data(&amp;self, owner: TRef&lt;Node&gt;) -&gt; &amp;LargeData {
        &amp;self.data
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The assumption with the above code is that <code>SignalEmitter</code> is holding data that is too large to be feasible to clone into the signal. So the purpose of the signal is to notify other Nodes or Objects that this the data has been updated.</p>
<p>The problem is that, unless the nodes all connect with the <code>Object::CONNECT_DEFERRED</code> flag, they will be notified immediately and will attempt to borrow the data. This is the root cause of the <code>BorrowFailed</code> error.</p>
<p>There are two ways to solve it.</p>
<ol>
<li>Ensure that all nodes use <code>Object::CONNECT_DEFERRED</code> since this will ensure that the callbacks wait until the idle_frame signal to borrow the data.</li>
<li>Store <code>data</code> in a <code>RefCell&lt;LargeData&gt;</code> if it should only be accessed from the same thread (such as with signals) or <code>Mutex&lt;LargeData&gt;</code> if you need thread-safety. Then you can modify <code>update_data()</code> to the following snippet:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update_data(&amp;self, owner: TRef&lt;Node&gt;, data: LargeData) {
        // If using RefCell
        self.data.replace(data);
        // If using Mutex
        // *self.data.lock().expect(&quot;this should work&quot;) = data;
        owner.emit_signal(&quot;updated&quot;, &amp;[]);
    }
<span class="boring">}
</span></code></pre></pre>
<p>In both instances you will not encounter the reentrant errors.</p>
<h2 id="why-do-mutating-godot-methods-take-self-and-not-mut-self"><a class="header" href="#why-do-mutating-godot-methods-take-self-and-not-mut-self">Why do mutating Godot methods take <code>&amp;self</code> and not <code>&amp;mut self</code>?</a></h2>
<ol>
<li><code>&amp;mut</code> means that only one reference can exist simultaneously (no aliasing), <em>not</em> that the object is mutable. Mutability is often a <em>consequence</em> of the exclusiveness. Since Godot objects are managed by the engine, Rust cannot guarantee that references are exclusive, as such using <code>&amp;mut</code> would cause undefined behavior. Instead, an interior mutability pattern based on <code>&amp;T</code> is used. For godot-rust, it is probably more useful to consider <code>&amp;</code> and <code>&amp;mut</code> as &quot;shared&quot; and &quot;unique&quot; respectively.
For more information, please refer to <a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html">this explanation</a> for more information.</li>
<li>Why godot-rust does not use <code>RefCell</code> (or some other form of interior mutability) is because the types already have interior mutability as they exist in Godot (and can't be tracked by Rust). For example, does <code>call()</code> modify its own object? This depends on the arguments. There are <a href="https://github.com/godot-rust/godot-rust/issues/808#issuecomment-964034258">many such cases</a> which are much more subtle.</li>
</ol>
<h2 id="why-is-there-so-much-unsafe-in-godot-rust"><a class="header" href="#why-is-there-so-much-unsafe-in-godot-rust">Why is there so much <code>unsafe</code> in godot-rust?</a></h2>
<p>Short Answer: Godot is written in C++, which cannot be statically analyzed by the Rust compiler to guarantee safety.</p>
<p>Longer Answer: <code>unsafe</code> is required for different reasons:</p>
<ul>
<li><strong>Object lifetimes:</strong> Godot manages memory of objects independently of Rust. This means that Rust references can be invalidated when Godot destroys referred-to objects. This usually happens due to bugs in GDScript code, like calling <code>free()</code> of something actively in use.</li>
<li><strong>Thread safety:</strong> while Rust has a type system to ensure thread safety statically (<code>Send</code>, <code>Sync</code>), such mechanisms do not exist in either GDScript or C++. Even user-defined GDScript code has direct access to the <code>Thread</code> API.</li>
<li><strong>C FFI:</strong> any interactions that cross the C Foreign Function Interface will be unsafe by default as Rust cannot inspect the other side. While many functions may be safely reasoned about, there are still some functions which will be inherently unsafe due to their potential effects on object lifetimes.</li>
</ul>
<p>One of the ways that godot-rust avoids large <code>unsafe</code> blocks is by using the <a href="http://cliffle.com/blog/rust-typestate/">TypeState pattern</a> with <em>temporary references</em> such as <code>TRef</code> and <code>TInstance</code>. For more information see <a href="../../src/gdnative-overview/wrappers.html"><code>Ref</code>, <code>TRef</code> and <code>Instance</code></a>.</p>
<p>Here is an example of some common <code>unsafe</code> usage that you will often see and use in your own games.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_a_node(&amp;self, owner: TRef&lt;Node&gt;) {
    // This is safe because it returns an option that Rust knows how to check.
    let child = owner.get_child(&quot;foo&quot;);
    // This is safe because Rust panics if the returned `Option` is None.
    let child = child.expect(&quot;I know this should exist&quot;);
    // This is also safe because Rust panics if the returned `Option` is None.
    let child = child.cast_instance::&lt;Foo&gt;().expect(&quot;I know that it must be this type&quot;);
    // This is unsafe because the compiler cannot reason about the lifetime of `child`.
    // It is the programmer's responsibility to ensure that `child` is not freed before
    // it gets used.
    let child: Instance&lt;Foo&gt; = unsafe { child.assume_safe() };
    // This is safe because we have already asserted above that we are assuming that
    // there should be no problem and Rust can statically analyze the safety of the
    // functions.
    child.map_mut(|c, o| {
        c.bar(o);
    }).expect(&quot;this should not fail&quot;);
    // This is unsafe because it relies on Godot for function dispatch and it is
    // possible for it to call `Object.free()` or `Reference.unreference()` as
    // well as other native code that may cause undefined behavior.
    unsafe {
        child.call(&quot;bar&quot;, &amp;[])
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>By the way, safety rules are subject to an <a href="https://github.com/godot-rust/godot-rust/issues/808">ongoing discussion</a> and likely to be relaxed in future godot-rust versions.</p>
<h2 id="can-the-new-constructor-have-additional-parameters"><a class="header" href="#can-the-new-constructor-have-additional-parameters">Can the <code>new</code> constructor have additional parameters?</a></h2>
<p>Unfortunately this is currently not possible, due to a general limitation of GDNative (see <a href="https://github.com/godotengine/godot/issues/23260">related issue</a>).</p>
<p>As a result, a common pattern to work around this limitation is to use explicit initialization methods. For instance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EnemyData {
    name: String,
    health: f32,
}

#[derive(NativeClass)]
#[inherit(Object)]
struct Enemy {
    data: Option&lt;EnemyData&gt;,
}

#[methods]
impl Enemy {
    fn new(_owner: &amp;Object) -&gt; Self {
        Enemy {
            data: None,
        }
    }

    #[export]
    fn set_data(&amp;mut self, _owner: &amp;Object, name: String, health: f32) {
        self.data = Some(EnemyData { name, health });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This however has two disadvantages:</p>
<ol>
<li>You need to use an <code>Option</code> with the sole purpose of late initialization, and subsequent <code>unwrap()</code> calls or checks -- weaker invariants in short.</li>
<li>An additional type <code>EnemyData</code> for each native class like <code>Enemy</code> is required (unless you have very few properties, or decide to add <code>Option</code> for each of them, which has its own disadvantages).</li>
</ol>
<p>An alternative is to register a separate factory class, which returns fully-constructed instances:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[no_constructor] // disallow default constructor
#[inherit(Object)]
struct Enemy {
    name: String,
    health: f32,
}

#[methods]
impl Enemy {
    // nothing here
}

#[derive(NativeClass)]
#[inherit(Reference)]
struct EntityFactory {}

#[methods]
impl EntityFactory {
    #[export]
    fn enemy(&amp;self, _owner: &amp;Reference, name: String, health: f32)
    -&gt; Instance&lt;Enemy, Unique&gt; {
        Enemy { name, health }.emplace()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>So instead of <code>Enemy.new()</code> you can write <code>EntityFactory.enemy(args)</code> in GDScript.
This still needs an extra type <code>EntityFactory</code>, however you could reuse that for multiple classes.</p>
<h2 id="can-i-implement-static-methods-in-gdnative"><a class="header" href="#can-i-implement-static-methods-in-gdnative">Can I implement static methods in GDNative?</a></h2>
<p>In GDScript, classes can have static methods. However, GDNative currently doesn't allow to register static methods from bindings.</p>
<p>As a work-around, it is possible to use a ZST (zero-sized type):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Copy, Clone, Default)]
#[user_data(Aether&lt;StaticUtil&gt;)]
#[inherit(Object)]
pub struct StaticUtil;

#[methods]
impl StaticUtil {
    #[export]
    fn compute_something(&amp;self, _owner: &amp;Object, input: i32) -&gt; i32 {
        godot_print!(&quot;pseudo-static computation&quot;);
        2 * input
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/gdnative/latest/gdnative/export/user_data/struct.Aether.html"><code>Aether</code></a> is a special user-data wrapper intended for zero-sized types, that does not perform any allocation or synchronization at runtime.</p>
<p>The type needs to be instantiated somewhere on GDScript level.
Good places for instantiation are for instance:</p>
<ul>
<li>a member of a long-living util object,</li>
<li>a <a href="https://docs.godotengine.org/en/stable/getting_started/step_by_step/singletons_autoload.html">singleton auto-load object</a>.</li>
</ul>
<h2 id="how-do-i-convert-from-a-variant-to-the-underlying-rust-type"><a class="header" href="#how-do-i-convert-from-a-variant-to-the-underlying-rust-type">How do I convert from a <code>Variant</code> to the underlying Rust type?</a></h2>
<p>Assuming that a method takes an argument <code>my_node</code> as a <code>Variant</code></p>
<p>You can convert <code>my_node</code> to a <code>Ref</code>, and then to an <code>Instance</code> or <code>TInstance</code>, and mapping over it to access the Rust data type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// My class that has data
#[derive(NativeClass)]
#[inherit(Node2D)] // something specific, so it's clear when this type re-occurs in code
struct MyNode2D { ... }

/// Utility script that uses MyNode2D
#[derive(NativeClass, Copy, Clone, Default)]
#[user_data(Aether&lt;AnotherNativeScript&gt;)] // ZST, see above
#[inherit(Reference)]
pub struct AnotherNativeScript;

#[methods]
impl AnotherNativeScript {
    #[export]
    pub fn method_accepting_my_node(&amp;self, _owner: &amp;Reference, my_node: Variant) {
        // 1. Cast Variant to Ref of associated Godot type, and convert to TRef.
        let my_node = unsafe {
            my_node
                .try_to_object::&lt;Node2D&gt;()
                .expect(&quot;Failed to convert my_node variant to object&quot;)
                .assume_safe()
        };

        // 2. Obtain a TInstance which gives access to the Rust object's data.
        let my_node = my_node
            .cast_instance::&lt;MyNode2D&gt;()
            .expect(&quot;Failed to cast my_node object to instance&quot;);

        // 3. Map over the RefInstance to process the underlying user data.
        my_node
            .map(|my_node, _owner| {
                // Now my_node is of type MyNode2D.
            })
            .expect(&quot;Failed to map over my_node instance&quot;);
    }

}

<span class="boring">}
</span></code></pre></pre>
<h2 id="is-it-possible-to-set-subproperties-of-a-godot-type-such-as-a-material"><a class="header" href="#is-it-possible-to-set-subproperties-of-a-godot-type-such-as-a-material">Is it possible to set subproperties of a Godot type, such as a <code>Material</code>?</a></h2>
<p>Yes, it is possible, but it will depend on the type.</p>
<p>For example, when you need to set an <code>albedo_texture</code> on the <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.SpatialMaterial.html"><code>SpatialMaterial</code></a>, it will be necessary to use the generic <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.SpatialMaterial.html#method.set_texture"><code>set_texture()</code></a> function with the parameter <code>index</code>.</p>
<p>While a similar case applies for <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ShaderMaterial.html"><code>ShaderMaterial</code></a> in the case of shader material, to set the shader parameters, you will need to use the <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ShaderMaterial.html#method.set_shader_param"><code>set_param()</code></a> method with the relevant parameter name and value.</p>
<p>Direct access to such properties is planned in <a href="https://github.com/godot-rust/godot-rust/issues/689">godot-rust/godot-rust#689</a>.</p>
<h2 id="what-is-the-rust-equivalent-of-preload"><a class="header" href="#what-is-the-rust-equivalent-of-preload">What is the Rust equivalent of <code>preload</code>?</a></h2>
<p>Unfortunately, there is no equivalent to preload in languages other than GDScript, because preload is GDScript-specific magic that works at compile time. If you read the official documentation on preload, it says:</p>
<blockquote>
<p>&quot;Returns a resource from the filesystem that is <em>loaded during script parsing.</em>&quot; <strong>(emphasis mine)</strong></p>
</blockquote>
<p>This is only possible in GDScript because the parser is deeply integrated into the engine.</p>
<p>You can use <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ResourcePreloader.html"><code>ResourcePreloader</code></a> as a separate node in your scene, which will work regardless of whether you use Rust or GDScript. However, note that if you create a <code>ResourcePreloader</code> in your code, you will still be loading these resources at the time of execution, because there is no way for the engine to know what resources are being added before actually running the code.</p>
<p>The <a href="https://docs.rs/gdnative/latest/gdnative/api/struct.ResourceLoader.html"><code>ResourceLoader</code></a> should be used in most cases.</p>
<p>Also, you can go with a <code>static Mutex&lt;HashMap&lt;..&gt;&gt;</code> variable and load everything you need there during a loading screen.</p>
<h2 id="how-can-function-parameters-accept-godot-subclasses-polymorphism"><a class="header" href="#how-can-function-parameters-accept-godot-subclasses-polymorphism">How can function parameters accept Godot subclasses (polymorphism)?</a></h2>
<p><em>Static</em> (compile-time) polymorphism can be achieved by a combination of the <code>SubClass</code> trait and <code>upcast()</code>.</p>
<p>For example, let's assume we want to implement a helper function that should accept any kind of <a href="https://docs.godotengine.org/en/stable/classes/class_control.html#class-control"><code>Container</code></a>. The helper function can make use of <code>SubClass</code> and <code>upcast()</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_container&lt;T&gt;(container: TRef&lt;'_, T&gt;)
    where T: GodotObject + SubClass&lt;Container&gt;
// this means: accept any TRef&lt;T&gt; where T inherits `Container`
{
    // First upcast to a true container:
    let container = container.upcast::&lt;Container&gt;();
    // Now you can call `Container` specific methods like:
    container.set_size(...);
}
<span class="boring">}
</span></code></pre></pre>
<p>This function can now be used with arbitrary subclasses, for instance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_usage() {
    let panel: Ref&lt;PanelContainer&gt; = PanelContainer::new().into_shared();
    let panel: TRef&lt;PanelContainer&gt; = unsafe { panel.assume_safe() };
    do_something_with_container(panel);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that <code>SubClass</code> is only a marker trait that models the inheritance relationship of Godot classes, and doesn't perform any conversion by itself. For instance, <code>x: Ref&lt;T&gt;</code> or <code>x: TRef&lt;'_, T&gt;</code> satisfying <code>T: GodotObject + SubClass&lt;Container&gt;</code> doesn't mean that <code>x</code> can be used as a <code>Container</code> directly. Rather, it ensures that e.g. <code>x.upcast::&lt;Container&gt;()</code> is guaranteed to work, because <code>T</code> is a subclass of <code>Container</code>. Therefore, it is a common pattern to use <code>SubClass</code> constraints in combination with <code>.upcast()</code> to convert to the base class, and actually use <code>x</code> as such.</p>
<p>Of course, you could also delegate the work to upcast to the call site:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_container(container: TRef&lt;Container&gt;) { ... }

fn some_usage() {
    let panel: TRef&lt;PanelContainer&gt; = ...;
    do_something_with_container(panel.upcast());
}
<span class="boring">}
</span></code></pre></pre>
<p>This would also support <em>dynamic</em> (runtime) polymorphism -- <code>Ref&lt;T&gt;</code> can also store subclasses of <code>T</code>.</p>
<h2 id="what-is-the-rust-equivalent-of-onready-var"><a class="header" href="#what-is-the-rust-equivalent-of-onready-var">What is the Rust equivalent of <code>onready var</code>?</a></h2>
<p>Rust does not have a direct equivalent to <code>onready var</code>. The most idiomatic workaround with Rust is to use <code>Option&lt;Ref&lt;T&gt;&gt;</code> of you need the Godot node type or <code>Option&lt;Instance&lt;T&gt;&gt;</code> if you are using a Rust based <code>NativeClass</code>.</p>
<pre><code class="language-gdscript">extends Node
class_name MyClass
onready var node = $Node2d
</code></pre>
<p>You would need to use the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass, Default)]
#[inherit(Node)]
#[no_constructor]
struct MyNode {
    // late-initialization is modeled with Option
    // the Default derive will initialize both to None
    node2d: Option&lt;Ref&lt;Node&gt;&gt;,
    instance: Option&lt;Ref&lt;MyClass&gt;&gt;,
}

#[methods]
impl MyNode {
    #[export]
    fn _ready(&amp;self, owner: TRef&lt;Node&gt;) {
        // Get an existing child node that is a Godot class.
        let node2d = owner
            .get_node(&quot;Node2D&quot;)
            .expect(&quot;this node must have a child with the path `Node2D`&quot;);
        let node2d = unsafe { node2d.assume_safe() };
        let node2d = node2d.cast::&lt;Node2D&gt;();
        self.node2d = Some(node2d.claim());

        // Get an existing child node that is a Rust class.
        let instance = owner
            .get_node(&quot;MyClass&quot;)
            .expect(&quot;this node must have a child with the path `MyClass`&quot;);
        let instance = unsafe { instance.assume_safe() };
        let instance = instance.cast_instance::&lt;MyClass&gt;()
                        .expect(&quot;child must be type `MyClass`&quot;);
        self.instance = Some(instance.claim());
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="what-types-are-supported-for-passing-through-the-gdnative-api"><a class="header" href="#what-types-are-supported-for-passing-through-the-gdnative-api">What types are supported for passing through the GDNative API?</a></h2>
<p>The GDNative API supports any type that implements the <a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.ToVariant.html"><code>ToVariant</code></a> and/or <a href="https://docs.rs/gdnative/latest/gdnative/core_types/trait.FromVariant.html"><code>FromVariant</code></a> traits.</p>
<p>To use a type as a property, in addition to the above, the type will also need to implement the <a href="https://docs.rs/gdnative/latest/gdnative/nativescript/trait.Export.html"><code>Export</code></a> trait.</p>
<p>Some concrete examples of types that can be used with the GDNative API are the following:</p>
<ul>
<li><a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.Variant.html"><code>Variant</code></a>, this is Godot's &quot;any&quot; type. It must be converted before it can be used.</li>
<li>A subset of scalar types such as <code>i64</code>, <code>f64</code>, <code>bool</code>, etc.</li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> and <a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.GodotString.html"><code>GodotString</code></a>.</li>
<li><a href="https://docs.rs/gdnative/latest/gdnative/core_types/index.html">Godot core types</a> such as <a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.Color.html"><code>Color</code></a>, <a href="https://docs.rs/gdnative/latest/gdnative/core_types/struct.Aabb.html"><code>Aabb</code></a>, <a href="https://docs.rs/gdnative/latest/gdnative/core_types/type.Transform2D.html"><code>Transform2D</code></a>, <a href="https://docs.rs/gdnative/latest/gdnative/core_types/type.Vector2.html"><code>Vector2</code></a>, etc.</li>
<li>Godot classes such as <code>Node</code>, <code>Reference</code>, etc. which must be accessed via <a href="https://docs.rs/gdnative/latest/gdnative/struct.Ref.html"><code>Ref&lt;T&gt;</code></a> (you can't pass them by value, because Godot owns them).</li>
<li>Any Rust struct that derives <a href="https://docs.rs/gdnative/latest/gdnative/derive.NativeClass.html"><code>NativeClass</code></a>, through <a href="https://docs.rs/gdnative/latest/gdnative/nativescript/struct.Instance.html"><code>Instance&lt;T&gt;</code></a>.</li>
</ul>
<h2 id="how-can-i-profile-my-code-to-measure-performance"><a class="header" href="#how-can-i-profile-my-code-to-measure-performance">How can I profile my code to measure performance?</a></h2>
<p>There are a lot of ways to profile your code and they vary in complexity.</p>
<p>The simplest way is to use the <code>#[gdnative::profiled]</code> procedural macro that enables Godot to profile the attributed function. This option is useful for comparing performance gains when porting GDScript code to Rust or as a way to understand the relative &quot;frame time&quot; of your code. Don't forget to compile Rust code with <code>--release</code>!</p>
<p>For more information about the Godot profiler, please refer to the <a href="https://docs.godotengine.org/en/stable/tutorials/debug/debugger_panel.html?highlight=profiler#profiler">official documentation</a>.</p>
<p>In order for Godot to profile your function, all the following must be true:</p>
<ul>
<li>The function belongs to a struct that derives <code>NativeClass</code>.</li>
<li>The function is included in an <code>impl</code> block that is attributed with the <code>#[methods]</code> attribute.</li>
<li>The function is attributed with <code>#[export]</code> attribute.</li>
</ul>
<p>As such, this method is <em>only</em> useful for exported code and is subject to the Godot profiler's limitations, such as millisecond accuracy in profiler metrics.</p>
<p>The following example illustrates how your code should look when being profiled:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(NativeClass)]
#[inherit(Node)]
struct MyClass {}

#[methods]
impl MyClass {
    fn new(_owner: &amp;Node) -&gt; Self {
        Self {}
    }

    #[export]
    #[gdnative::profiled]
    fn my_profiled_function(&amp;self, _owner: &amp;Node) {
        // Any code in this function will be profiled.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you require insight into Rust code that is not exported to Godot, or would like more in-depth information regarding execution of your program, it will be necessary to use a Rust compatible profiler such as <a href="https://crates.io/crates/puffin">puffin</a> or <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a>. These tools can be used to more accurately determine bottlenecks and the general performance of your Rust code.</p>
<p><strong>Note:</strong> There are many more profilers than the ones listed and you should do your own research before selecting which one you wish to use.</p>
<p>For more information about profiling and other rust performance tips, please check out the <a href="https://nnethercote.github.io/perf-book/profiling.html">Rust performance book</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../faq.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../faq/multithreading.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../faq.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../faq/multithreading.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
